<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css-rem]]></title>
    <url>%2F2018%2F10%2F25%2Fcss-rem%2F</url>
    <content type="text"><![CDATA[今天在使用rem中发现了一个之前没注意的点 html { font-size: 10px; } .title { font-size: 1.6rem; } .container { width: 2.4rem; } 其中title的字体大小为16px，但是container的宽度却是28.8px，我算了一下28.8/2.4=1.2，想到浏览器的最小字体是12px，所以我想着可能和最小字体的大小有关系。 于是我尝试将chrome的最小字体设置为最小（比12px小），发现container的宽度是24px。 去查资料没有找到相应的资料，可以了解的是rem最好使用在font-size上，使用在margin和padding上也会出现和期望不同的值。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[two-select-change-one]]></title>
    <url>%2F2018%2F10%2F22%2Ftwo-select-change-one%2F</url>
    <content type="text"><![CDATA[今天写了一个方法，被问到这两个查询能改成一个查询吗？ def get_producer_name str = producers.limit(3).map{ |producer| producer.name } str += '等' if producers.count > 3 end 在上面的代码中，producers.limit(3)和producer.count会进行两次查询，要变成一个查询，肿么办？ def get_producer_name pros = producers.limit(4) str = pros[0...2].map{ |producer| producer.name } str += '等' if pros.length > 3 end 一次性查出来前四条！这个方式真的很赞👍！是否给了你新的idea🤔️]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>pg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stimulus-begin]]></title>
    <url>%2F2018%2F10%2F22%2Fstimulus-begin%2F</url>
    <content type="text"><![CDATA[demostimulusts作为js的超集，应用率也是非常广泛，在github上看到一个有趣的框架，于是想着从hello word走起，看完栗子有，我尝试写一个列表… &lt;div data-controller="content-loader" data-content-loader-url="/message.html" data-content-loader-refresh-interval="5000">&lt;/div> &lt;h1>list controller&lt;/h1> &lt;div data-controller="list" data-list-initial='["name"]'> &lt;div> &lt;input type="text" data-target="list.text" value="hello1"> &lt;button data-action="click->list#add">add&lt;/button> &lt;/div> &lt;div data-target="list.items">&lt;/div> &lt;/div> import { Controller } from 'stimulus'; export default class extends Controller { static targets = ['text', 'items', 'item']; connect() { this.getInitialItems(); } get items() { return this.items; } set items(newItems) { this.items = newItems; this.render(newItems); } get text() { return this.textTarget.value; } getInitialItems() { try { this.items = JSON.parse(this.data.get('initial')); } catch(e) { this.items = []; console.error(e) } } render(items) { this.itemsTarget.innerHTML = items.reduce((acc, item, index) => { return acc + `&lt;p data-target="list.item">&lt;span>${item}&lt;/span>&lt;button data-id="${index}" data-action="click->list#deleteItem">delete&lt;/button>&lt;/p>`; }, ''); } add() { this.items = this.items.concat(this.text); } deleteItem(event) { const targetIndex = event.currentTarget.dataset.id; const newItems = [ ...this.items.slice(0, targetIndex), ...this.items.slice(targetIndex + 1) ]; this.items = newItems; } } 看起来非常good，于是开始运行，发现死循环了，检查了代码没发现错误，尝试debugger发现程序一直在执行set操作，很纳闷，没执行set呀。找机会问了哟哟，他告诉我，在set中尝试给this.item意味着你在set调用set本身，于是乎，死循环了… get items() { return this._items; } set items(newItems) { this._items = newItems; this.render(newItems); } 修改成以上代码可以正常工作。 思考：1、如果以上面的方式进行，我觉得还不如做成面向对象中的set/get….这只是我个人的想法 将html写在js中一点都不优雅，我找到了一个demo，它提供一个更好的方式。 使用stimulus，思维方式和传统的js相似 在stimulus中，数据和元素不是一一对应的，所以在deleteItem中直接删除元素并且改变items的方式会不会比通过数据去改变dom更好一点？虽然二随一变会容易出bug，但是考虑到列表可能会很多，删除一个元素比重新渲染整个列表代价小很多吧…..]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whether-to-use-react]]></title>
    <url>%2F2018%2F10%2F14%2Fwhether-to-use-react%2F</url>
    <content type="text"><![CDATA[最近在重构项目中，发现了很多过度使用react的地方，现在想想原因是：1. 时间紧迫 2.被react的状态管理迷花了眼睛，总之是没磨好刀就砍柴了… 又一个左右布局三七分的页面，左边是一堆可以switch check的条件，右边的上部是checked的条件，中间是筛选结果列表，下部是分页。 使用react实现，总之要注意的是对状态的管理。但如果是使用jq实现，我仔细的想了一下，啊，左边和右边上部的数据的一致性可以通过元素选择器来保证，总之，使用jq，没有了一个全局状态，右边需要获得checked的条件，只能通过元素的不同来得到，假如选择的条件改变了，我需要先去获得选择的条件，然后再去改变右边的dom，我该如何去渲染dom，写一个函数，输入变量，输出为html string，咦，这不相当于react component嘛。 总之，使用react去实现是维护的一个全局状态变量，使用jq，是通过dom去得到状态变量…这是我对两种实现方式的认知….至于使用哪一个，还需要了解一下需求… PS：总之，离开了react，使用js不是一个困难的事情，磨刀呀…]]></content>
      <categories>
        <category>react</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reference-equality-and-value-equality]]></title>
    <url>%2F2018%2F09%2F26%2Freference-equality-and-value-equality%2F</url>
    <content type="text"><![CDATA[在编程语言世界中通常有两种类型的相等： reference equality value equality 引入思考下面的代码： var x = 12, y = 12; var object = { x: 1, y: 2 }; var object2 = { x: 1, y: 2 }; 正如你看到的，object和object2有相同的值。如果你看一下object和object2中的每个键以及它们对应的值，它们是相同的。在object和object2中，x的值是1，y的值是2。 但是当你想要在你的程序中检查object和object2是否相等，你会发现：这两个对象是不一样的。 object == object2 // false object === object2 // false 这是为什么呢？ reference equalityObjects是灰常复杂的数据结构。它们可以有很多key，这些key可以执行不同的值。这些值也可以是objects，所以objects是可以嵌套的。 如果你考虑事物的相等行，事实上你需要考虑两件事情： 一个事物是否意味着与另一个事物相同？ 一个事物与其它东西完全一样？ 如果我从现实世界中举一个例子：想象一下你有一个红色的跑车，你的邻居也有和你的车一样的车，相同的颜色，相同的发动机，相同的牌子。如果陌生人经过你的家，他们会说：嘿，这些人有相同的车。 但是，你邻居的车不是你的。你不会坐上邻居车，认为这是你的，对吧，或者至少你不应该。如果你撞坏了邻居的车，你可能会有一个不快乐的邻居，当然还有一些法律问题:) 区分你的车和邻居的车的最明显的地方是车牌。 事实上， JavaScript objects的内置了这种“牌照”，每个object的独特特性称为reference（引用）。当你在js中比较object时，它们通过reference比较 object == object2; object === object2; 问题：object和object2是相等吗？实际上你分配变量的时候，也分配了reference。你可以很容易的检查这个： object = object2; object == object2; // true object === object2; // true 也会有一些有趣的结果，代码如下： object = object2; object.x = 12; object.x; // 12 object2.x; // 12 在这个例子中，你做了一次将x这个key分配给object这个对象。object和object2指向相同的引用，所以只要一个变量更改，另一个变量也会更改。 JavaScript中的复杂的数据结构都遵循reference equality的原则，这包括arrays和objetcs，实际上通过typeof查看array的类型，得到的结果也是object。 还有一些值像：numbers, strings, booleans or null / undefined，它们都遵循一种相等：value equality。 value equality像前面说的，reference equality回答的是object1和object2是否一样？这种检查很简单，它们非常有效。 说到Javascript中的primitives（这个我也不知道怎么翻译，指的是上面的numbers等，它们是不可以嵌套的。这种不能嵌套其它结构的结构称为shallow data structures（浅数据结构）。在这样的结构中，你可以以有效的方式执行value equality。 但是什么是value equality？思考下面的代码： var x = 12, y = 12; 在相等方面，数字是最简单的。你可以清楚的说x变量的值等于y变量的值（12在数学中等于12）但是如果这些变量遵循reference equality，它们是不一样的，因为它们是在不同的地方创建的。所以它们的引用是不同的。x的12可能是和y的12是不一样的。这真是太乱了。 幸运的是，members在JavaScript中是primitives，primitives在javascri中使用的是value equality进行比较。所以看到这是不奇怪的： x == y; // true x === y; // true value equality回答的是这个疑问：一个事物是否意味着与另一个事物相同？ 嵌套的数据结构是的相等更加难以比较。Objects有任意的key和value，它可以包含其他的objects。为了比较两个objects的相等，你可能需要下面的算法： / Input: an object1 and object2 // Output: true if an object1 is equal in terms of values to object2 valueEqual(object1, object2): object1keys = &lt;list of keys of object1> object2keys = &lt;list of keys of object2> return false if length(object1keys) != length(object2keys) for each key in object1keys: return false if key not in object2keys return false if typeof(object1[key]) != typeof(object2[key]) if object1[key] is an object: keyEqual = valueEqual(object1[key], object2[key]) return false if keyEqual != false if object1[key] is a primitive: return false if object1[key] != object2[key] return true 呼，这里面有好多相等检查，这是一个递归算法。它在比较两个object是会执行上千次相等检查，这样的相等检查通常被称作 deep equality checks（深比较）。更糟糕的是，这个算法是不会完成的。这是因为你可能创建了循环的引用对象。 PS：参考链接]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[immutable-data]]></title>
    <url>%2F2018%2F09%2F25%2Fimmutable-data%2F</url>
    <content type="text"><![CDATA[项目中的apollo主要是用的分页这个功能，但是我在check代码的时候，发现了每次我向列表中push了一个数据，整个列表是全部re-render!!!假如每个是十条数据，等我滑到第十页的时候，100个item是全部re-render的…我去查apollo fetch updata 没有找到结果，我向react-apollo提了issue，感谢G友captDaylight给我的回复。 When you update an item in a list with immutablility helper its returning a brand new array, so it’ll have a new reference. So that list in React’s eyes is completely new, even if structurally most of the items in the array are the same. Thus each item will be re-rendered. 开始，我的重点是放在immutablility-helper，但是查了好久也没找到why 这个时候，我查了项目中使用state的列表，发现它只会re-render新增的数据，于是我使用redux来渲染list，发现它也是全部re-render所有item。state和redux的差异在哪？redux中使用的是immutable data，于是我去查文档。 1. What are the benefits of immutabilityimmutability可以为你的应用程序带来更高的性能，并且可以简化变成和调试。在整个应用程序中，从不会更改的数据比可以随意更改的数据更容易理解。 特别的，Web应用程序环境中的不变性可以使复杂的变更检测变得更简单和廉价，确保计算成本高昂的DOM更新过程只发生在绝对必要的时候（这是React相对于其他库性能改进的基石）。 2. Why is immutability required by Redux? Redux和React-Redux都使用浅等式检查。尤其是： Redux的combineReducers实用程序浅层检查由它调用的reducer引起的引用变化。 React-Redux的connect方法生成的组件浅层地检查对根状态的引用更改，以及来自mapStateToProps函数的返回值，以查看包装的组件是否实际需要re-render immutable data的管理最终使数据更安全 Time-travel debugging要求reducers是没有副作用的纯函数，因此你可以在不同的状态之间正确跳转。 3. Why does Redux’s use of shallow equality checking require immutability?如果要正确的更新任何connected组件，Redux使用 shallow equality checking（浅检查），要了解原因，我们需要了解 shallow equality checking和deep equality checking（深检查）之前的区别。两者的区别是：shallow equality checking只是简单的检查两个不同的变量是否是相同的引用；相反，deep equality checking必须检查两个对象属性的每个值。 4. How does Redux use shallow equality checking？Redux在combineReducers函数中使用浅等式检查来返回根状态对象的新变异副本，或者，如果没有进行任何突变，则返回当前根状态对象。 5.How does React-Redux use shallow equality checking?当根状态对象的引用改变时，对于有mapStateToProps的组件，检查mapStateToProps的返回值，如果返回值不变，则组件不会re-render。 对于下面这个组件，如果state.todos和getVisibleTodos返回的值不变时，这个组件不会re-render function mapStateToProps(state) { return { todos: state.todos, // prop value visibleTodos: getVisibleTodos(state) // selector } } ​ export default connect(mapStateToProps)(TodoApp) 对于下面这个组件，始终会re-render，因为todos的值始终是新对象，无论它的值是否更改 // AVOID - will always cause a re-render function mapStateToProps(state) { return { // todos always references a newly-created object todos: { all: state.todos, visibleTodos: getVisibleTodos(state) } } } ​ export default connect(mapStateToProps)(TodoApp) 6. 如何避免不必要的render？和shouldComponentUpdate搭配使用，PS:shouldComponentUpdate返回的值是建议性的，所以在组件中你返回false，组件有可能re-render。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[high-oreder-component-tip]]></title>
    <url>%2F2018%2F09%2F20%2Fhigh-oreder-component-tip%2F</url>
    <content type="text"><![CDATA[question今天遇到了一个问题：写了一个高阶组件，使用的时候竟然告诉我props is required, but it is undefined??? // FormWrapper.jsx const FormWrapper = initialState => Component => { class FormInnerWrapper extends React.Component { state = initialState checkFeildValid = (value, type) => { // ... } changeValue = (value, type) => { // ... } isFormValidate = () => { // ... } render() { return &lt;Component data={this.state} changeValue={this.changeValue} isFormValidate={this.isFormValidate} {...this.props} />; } } return FormInnerWrapper; }; FormWrapper.propTypes = { initialState: PropTypes.object.isRequired, }; export default FormWrapper; // MyForm.jsx @FormWrapper({ xxx: 'xxx', xxxx: 'xxx' }) class MyForm extends React.Component { // ... } MyForm.propTypes = { isFormValidate: PropTypes.func.isRequired, data: PropTypes.object.isRequired, changeValue: PropTypes.func.isRequired, }; export default MyForm; react给我三个warning： The prop `data` is marked as required in FormInnerWrapper, but it is undefined. The prop `isFormValidate` is marked as required in FormInnerWrapper, but it is undefined. The prop `changeValue` is marked as required in FormInnerWrapper, but it is undefined. debug我检查了代码，发现我没有对FormInnerWrapper定义propTypes， 我只对MyForm进行了propTypes定义。我尝试给MyForm加上defaultProps,其中data的default值为null，在调试的时候发现data的值永远为null, 不会去改变🤔️。发生了什么？ plan B于是我尝试了下面的格式： // MyForm.jsx export default FormWrapper({ xxx: 'xxx', xxxx: 'xxx' })(MyForm); 发现没有warning。 why装饰器的写法是从左到右执行？？？第二种写法比较符合正常的调用顺序？？我需要再去查decorator与HOC的具体区别…PS: 上次的immutable data疑问，在今天终于得到了解决，下一篇见～]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stateless-component-vs-pure-component]]></title>
    <url>%2F2018%2F09%2F13%2Fstateless-component-vs-pure-component%2F</url>
    <content type="text"><![CDATA[介绍1. stateless componentstateless component声明为一个没有state的function const Article = (props) => { return ( &lt;div> // ... &lt;/div> ) } react的文档中这样说到： These components must not retain internal state, do not have backing instances, and do not have the component lifecycle methods. They are pure functional transforms of their input, with zero boilerplate. However, you may still specify .propTypes and .defaultProps by setting them as properties on the function, just as you would set them on an ES6 class. 2. pure componentpure component是最大的意义是优化React应用的性能。使用PureComponent可以大大的提高性能，因为它减少render的次数。 3. 对比两者的性能class Welcome extends React.PureComponent { render() { return &lt;h1>Welcome&lt;/h1> } } Hello = () => { return &lt;h1>Hello&lt;/h1>; } 以上例子是一个非常简单的Welcome(Pure Component)和Hello(Stateless Component)。当你在父组件中使用它们，你会发现当父组件re-render时，Hello就会re-render，但是Welcome就不会。 这是因为PureComponent改变了生命周期中的shouldComponentUpdate方法，并且添加了一些逻辑用来自动检查组件是否需要re-render。这允许PureComponent仅仅在检测到state或者props改变时，才会调用render方法。 使用1. 什么时候使用Pure Component假如你创建一个字典的页面，在该页面中显示所有以A开头的单词的含义。这个时候，你可以写一个接收props为heading和meaning并返回视图的组件。假如你使用分页每次只显示10个单词，当滚动时，再去请求另外10个单词并且在父组件中更新state。在这种情况下，应该使用Pure Component，它将会避免render之前请求到的所有单词。 此外，在你要使用Component的生命周期函数时，你必须使用Pure Components，因为stateless components没有生命周期函数。 2. 什么时候使用Stateless Component假如你想要创建一个漂亮UI的lable用来评估个人资料的可信度，例如初学者，中级，高级。由于它是一个很小的组件，其重新渲染几乎没有任何区别，并为这种small case创建一个新的组件将是耗时的。如果你继续为很小很小的view创建组件，很快，你将会遇到更多的组件，在一个大型项目中，它们会变得很难管理。同时应该牢记Pure Component具有shallowEqual（浅比较）的特性。 3. 结论Pure Components会使性能大幅提升，因为它减少了应用中render的次数。这对于一份复杂的UI是个巨大的胜利，因此建议尽可能的使用。此外还有一些情况需要使用生命周期函数，在这种情况下，我们不能使用stateless components。 Stateless Components可以简单而快速的实现。这对于一个re-render代价小的非常小的UI视图是很好的。它们提供更清晰的代码和更少的文件来处理。它最好的使用场景应该是在父组件为Pure Component或者HOC中使用。 后记项目中使用的Apollo，我尝试将stateless component改为pure component，但是组件还是会re-render。Apollo中数据是immutiable，并且每个item在list中都有key，但是不知道为什么还是会重新渲染，十分纳闷啊。我已经提了issue，期待有答复～如果找不到好的方法来解决，我只能为每个pure comoponent增加shouldComponentUpdate了… 参考链接]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-blog]]></title>
    <url>%2F2018%2F09%2F08%2Freact-blog%2F</url>
    <content type="text"><![CDATA[react的生命周期 问答 ajax为什么不在componentWillMount进行，而在componentDidMount中进行？ajax是一个异步操作，在render调用之前，不会在一步操作中返回数据，这意味着组件将使用default数据呈现至少一次；同时，在异步操作的callback中更新state不会触发re-render。另外，没有办法在等到返回数据后再去掉用render。react文档建议到：componentDidMount会在组件挂载后立即调用，需要dom节点的初始化应放在这里。如果你想远程获得数据，这是实例化网络请求的好地方。在这个方法中，调用setState这个方法会触发额外的render，它保证会在同一时间刷新，意为：即使你在这个情况下中调用render两次，用户不会看到中间的状态。 componentWillReceiveProps会执行一次还是多次？多次，所以你在这个使用这个方法时，需要比较current props和 next props。 setState是同步的还是异步的？异步。setState会触发re-render，如果是同步的话，可能会导致浏览器无反应。异步是为了获得更好的UI体验和性能。 Component和PureComponent的区别？PureComponent在shouldComponentUpdate中对props进行浅比较，而Component则进行深比较。 react的事件机制react中的事件在真实DOM中是全部挂在以事件代理的方式挂在document上面，事件代理的机制是事件冒泡。这是在react的事件中使用原生的阻止事件冒泡不起作用的原因。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weapp-tip]]></title>
    <url>%2F2018%2F09%2F01%2Fweapp-tip%2F</url>
    <content type="text"><![CDATA[如果你使用了canvas 、map类的组件，因为小程序是使用原生控件，无论你是怎样调整z-index，都不可能覆盖到这类组件上。网传的z-index设置为1000以上，经过实践是不起作用的。请使用cover-view。但是cover-view无法增加shadow和border。border可以通过使用cover-view的背景色来代替。shadow可以使用cover-image来代替。 正确的选择scroll-view和page。两者都能实现下拉刷新，上拉加载。通过业务，选择最适合的方案。 自定义导航栏时，通过getSystemInfo得到statusBarHeight在页面上使用px定义，而不是rpx来定义。 自定义导航栏时，如果有监控page的滚动的需求，请选择scroll-view来实现。在使用onPageScroll时，在iphonex上会导致上方自定义的导航栏抖动。测试的时候，会看到页面滚动时，iphonex上方有1px的空隙…. 小程序在iphonex的下方的安全边距为68rpx ios上会有自带的橡皮筋效果，记得保证页面下部的颜色与page的背景色相同 如果想实现保存图片的功能，需要通过canvas去画出图片，canvas的高度需要按照实际的内容计算出来。 待续…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[joker-weapp]]></title>
    <url>%2F2018%2F08%2F28%2Fjoker-weapp-4%2F</url>
    <content type="text"><![CDATA[今天遇到的一个问题是：在页面滚动过程中，可能会导致fixed的元素被遮盖住（偶尔），这个bug早在17年就被提及，但是到现在还没有修复… 键盘弹起对于页面有两个选择，是否推起页面，尴尬的是推起页面，页面会滑动；不推起页面，动态改变fixed的元素的bottom，也很尴尬；不知道有没有好的办法； 建议小程序出一个设计趋势，很多坑的出现是因为在小程序中使用和app等同的效果，生态局限性对开发者是一个很大的挑战，也是一个巨浪费时间的开发过程…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mixed-talk-1]]></title>
    <url>%2F2018%2F08%2F26%2Fmixed-talk-1%2F</url>
    <content type="text"><![CDATA[今天读到一本书，其中有一句话很有感触： 我们很容易沉浸在技术里，而忽略了生命的真谛。 当然这不是一本讲技术的书，但它成功的引起了我的注意。 人生处处是矛盾，人以主观意识来认识别人，但主观意识又会影响你对对方现在的感觉。士别三日刮目相看，即是处理矛盾的一种方式，以主观并且发展的眼光看待别人。 大一大二的课程最主要的是学习语言与算法。大三的课程是来学习关于产品和测试的。由于大三的可能比较偏重于理论，所以对待起来不是太看重。如此一来，等到毕业答辩的时候，矛盾就凸显出来了。 对待毕业项目来说，我是抱着一定要用到最新的技术来的。我使用express搭了一个框架，使用mongodb作为数据库。继而，手机端适应inoic做了一个webapp，当时觉得自己的目的已经达到了，我尝试使用了比较流行的技术做出来了一个还能看的demo（那时候的整体逻辑很是简单，现在一看到处是bug，看上去比较无组织无纪律）。在小组答辩，老师会注重看你的demo，进入大组后，评委就注重论文了。在我答辩完，评委问我：有人在用吗？我说没有。之所以我把它叫做demo，我就没把它当作一个产品来对待。但是评委们要的是一个产品，他们不会care你用了什么技术，他们只是要一个结果：成熟的产品。这是一个很矛盾的事情，究其原因，就是二者的关注点不同，我关注的是技术，对方关注的是一个成熟的产品，关注点不同，最后出现矛盾是一个再正常不过的是事情。总之，这是我遇到的第一件充满矛盾的事情。 最近遇到的一件事是，黑发（暂且这么叫吧，因为他的头发真的好多啊）问了我一切基础的问题。虽然自身没有为这些问题做任何准备，但是想着应该也能答上来吧。印象最深刻的问题是时间委托的机制，emmm，当时对这个问题手足无措，我最先想到的是设计模式。我说的是一塌糊涂，现在想想是在瞎扯。接着又问我委托的原理，依然一脸懵逼，我问了答案：事件冒泡。啊，我怎么把这么基础的给忘了呢。。。总之给我带来的冲击很大。结果又问我jsonp的机制，我又是一脸懵逼，黑发很震惊：你是真不知道还是假不知道…我排斥跨域，所以就没有了解过…黑发告诉我跨域这种场景还是很常见的，即使你排斥，但也需要了解它… 经过这次交谈，我不仅想，我到底做了些什么… 想了想大部分的工作时间都在写业务，业余的时间，自己就捣鼓一些小东西或者看一些书，拓展思维。大部分的时间，都在想着解决问题。例如事件委托，我是把它当作一个解决方法来看，当我遇到类似的问题，我会想到用这个方法来解决…我仅仅把它当作一个答案来看…渐渐的，我忘了本质。这个时候忽然想到在大学的时候，有位院长给我们上课，讲的内容也很是高深，根本就听不懂啊。我把这种现象称之为：title越高，就渐渐的忽略了最基础的东西。这与我现在的状况，不谋而合。 在技术的长河中，不仅需要积极的寻找解决问题的方法，还需要了解技术的本质。 这是今天的杂谈，明天也是元气满满的一天哦，不对，已经明天了，今天也是元气满满的一天哦😄]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[joker-xiaochengxu-3]]></title>
    <url>%2F2018%2F08%2F24%2Fjoker-weapp-3%2F</url>
    <content type="text"><![CDATA[如何自定义导航栏？ 这个需求的来源是：我向朋友转发了小程序中的页面，对方打开后，左上角是没有返回按钮的，这时候，右上角有一个去主页的标志是很合适的… app.json中设置属性: navigationStyle这意味着你的小程序是全屏显示的，title，还有左上角的路由状态需要自己去处理 每个设备的上面的statusbar的高度是不一样的，自制的导航栏的高度就是未知的，这个只能通过getSystemInfo去获得 需要对之前的fixed做一下处理，还是需要statusbar的值，设置margin-top 目前是这样的一个思路，暂时没发现其它的问题…顺便吐槽一句，小程序的开发者是经历过从C++转到python嘛….]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[joker-xiaochengxu-2]]></title>
    <url>%2F2018%2F08%2F24%2Fjoker-weapp-2%2F</url>
    <content type="text"><![CDATA[如何在小程序里面保存图片？ plan小程序可以将canvas保存成一张图片。现在主要的任务是将canvas中的内容画出来web端有一个叫做html2canvas，对于小程序，暂时没有找到相似的工具库…只能自己来画了目前，需要画出来的是： 背景纹理 title 图片 progress设置画布的大小ctx.rect(0, 0, width, height); 这里的遇到的问题，如何得到画布的高度…我先用html写出来结构，得到内容的高度，另一种方法是先去计算，emmm…这种方法还没想好思路 8-27更新：使用html的高度，和canvas画出来的排版不一样，不同的手机上的排版还不一样，最后导致的问题是在不同的手机上导出的图片要不是过短要不就是下面长出一截，最好还是一个一个元素的计算吧，确定每个元素的起点的y坐标 heightInfo.hrTop = heightInfo.xxxxxTop + titleInfo.height + 20; heightInfo.xxxxTop = heightInfo.hrTop + 24; heightInfo.xxxTop = heightInfo.xxxxTop + 14 + 20; heightInfo.xxxxTop = heightInfo.xxxTop + xxxInfo.height + 36; heightInfo.xxxxTop = heightInfo.xxxxTop + 90 + 7; this.height = heightInfo.xxxxTop + 14 + 30; 在这个过程中可以直接将多行字符串分割….还有一个将数字定义成常量 画背景纹理，每隔10画一条横线，竖线这个是重复画线的一个过程 drawLine: function(fromX, fromY, toX, toY, lineWidth = 1) { this.ctx.beginPath(); this.ctx.setLineWidth(lineWidth) this.ctx.moveTo(fromX, fromY); this.ctx.lineTo(toX, toY); this.ctx.stroke(); }, // .... const step = 10; const countX = width / step; const countY = height / step; for (let i = 0; i &lt; countX; i++) { drawLine(i * step, 0, i * step, height); } for (let i = 0; i &lt; countY; i++) { drawLine(0, i * step, width, i * step); } title涉及到文字换行，canvas不能主动对超出的文字做换行处理，处理的方法是拿到字符片段长度与最大宽度依次比较 const arrText = text.split(''); const line = ''; for (let n = 0; n &lt; arrText.length; n++) { const testLine = line + arrText[n]; const metrics = this.ctx.measureText(testLine); const testWidth = metrics.width; if (testWidth > maxWidth &amp;&amp; n > 0) { // 超出一行，打印 ctx.fillText(line, x, y); line = arrText[n]; y += lineHeight; } else { line = testLine; } } ctx.fillText(line, x, y); 图片这个涉及到居中显示 // 计算出图片的起始点即可 // use drawImage 过程中遇到的问题canvas的层级过高，会遮盖view元素，解决办法是使用：croll-view另一个问题是：croll-view设置border或者box-shadow不起作用，次而求之，再用一个croll-view假装边框吧….]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[joker-xiaochengxu]]></title>
    <url>%2F2018%2F08%2F17%2Fjoker-weapp%2F</url>
    <content type="text"><![CDATA[在这个可爱的节日里，让我来说说，写小程序的坑～ 对小程序的期待就像对vue的期待一样，看着文档就能写…可是，我踩了一个又一个的坑… textarea的padding问题为textarea设定了上下12rpx的内边距，在安卓机上十分完美，但是从测试那边反馈的结果是：框太高了…于是就去看看网上的讨论，在这吐槽一下，度娘真的是用中文都检索不出来结果…查了结果之后，发现textarea的内边距在安卓和iOS上的差别很大…我有以下方案： 不使用textarea的内边距，外面套一层view，为view添加内边距。实践的结果是：不行。看到有答案说：textarea使用的原生组件，任何padding、line-height都对此不起作用 为view设置box-sizing: border-box，这么一设置，textarea的auto-height都不起作用了，扎心… 没办法了，我只能去区别手机系统了：wx.getSystemInfo({ success: (res) => { if (res.model.match('iPhone X') !== null) { this.globalData.isIphoneX = true; } if (res.platform === 'ios') { this.globalData.isAndroid = false; } } }) view层通过判断getApp().globalData.isAndroid的值，如果为true，则加padding，否则，不加 padding。 iphone的橡皮筋效果如果你的页面有header、body、footer，header是白色，body是灰色，footer是白色，page本身是灰色，那么你在iphone上上拉页面，会看到灰中一块白，如何去调整，当然是遮盖再遮盖…这个效果，体验特别差… iphone X的安全边距找到的资料是安全边距是68rpx，这个时候，如果你有一个固定到下方的footer，和出现上面的问题，那么一定得好好想想如何去遮遮遮… input和textarea的选择textarea有一个auto-height的属性，可以自动根据内容去改变高度；但是input有手机键盘会有完成而不是回车的键，同时也会有一个点击完成键盘不收起的选项；总之你可以根据这两个特性去选择你需要的组件，加入需要input的属性，又需要textarea的属性，input是最好的选择…以我的经验来说 页面即有上拉加载又有下拉刷新一定要选用Page的特性，而不是scroll-view 打开键盘是否推起页面先考虑不推起页面，再考虑推起页面…因为推起页面显得特别不自然…. 得到globalData中的值如果你想以下面的格式来得到globalData的值，可能会出乎你的意料 Page({ data: { isIphoneX: app.globalData.isIphoneX, // 同步得到，可以得到正确的值 isLogin: app.globalData.isLogin, // 异步得到，得不到正确的值 }, }) 没办法，我只能在page的onload中再重新赋值一次…. 8-17，先写到这…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[joker-xiaochengxu]]></title>
    <url>%2F2018%2F08%2F17%2Fjoker-xiaochengxu%2F</url>
    <content type="text"><![CDATA[在这个可爱的节日里，让我来说说，写小程序的坑～ 对小程序的期待就像对vue的期待一样，看着文档就能写…可是，我踩了一个又一个的坑… textarea的padding问题为textarea设定了上下12rpx的内边距，在安卓机上十分完美，但是从测试那边反馈的结果是：框太高了…于是就去看看网上的讨论，在这吐槽一下，度娘真的是用中文都检索不出来结果…查了结果之后，发现textarea的内边距在安卓和iOS上的差别很大…我有以下方案： 不使用textarea的内边距，外面套一层view，为view添加内边距。实践的结果是：不行。看到有答案说：textarea使用的原生组件，任何padding、line-height都对此不起作用 为view设置box-sizing: border-box，这么一设置，textarea的auto-height都不起作用了，扎心… 没办法了，我只能去区别手机系统了：wx.getSystemInfo({ success: (res) => { if (res.model.match('iPhone X') !== null) { this.globalData.isIphoneX = true; } if (res.platform === 'ios') { this.globalData.isAndroid = false; } } }) view层通过判断getApp().globalData.isAndroid的值，如果为true，则加padding，否则，不加 padding。 iphone的橡皮筋效果如果你的页面有header、body、footer，header是白色，body是灰色，footer是白色，page本身是灰色，那么你在iphone上上拉页面，会看到灰中一块白，如何去调整，当然是遮盖再遮盖…这个效果，体验特别差… iphone X的安全边距找到的资料是安全边距是68rpx，这个时候，如果你有一个固定到下方的footer，和出现上面的问题，那么一定得好好想想如何去遮遮遮… input和textarea的选择textarea有一个auto-height的属性，可以自动根据内容去改变高度；但是input有手机键盘会有完成而不是回车的键，同时也会有一个点击完成键盘不收起的选项；总之你可以根据这两个特性去选择你需要的组件，加入需要input的属性，又需要textarea的属性，input是最好的选择…以我的经验来说 页面即有上拉加载又有下拉刷新一定要选用Page的特性，而不是scroll-view 打开键盘是否推起页面先考虑不推起页面，再考虑推起页面…因为推起页面显得特别不自然…. 得到globalData中的值如果你想以下面的格式来得到globalData的值，可能会出乎你的意料 Page({ data: { isIphoneX: app.globalData.isIphoneX, // 同步得到，可以得到正确的值 isLogin: app.globalData.isLogin, // 异步得到，得不到正确的值 }, }) 没办法，我只能在page的onload中再重新赋值一次…. 8-17，先写到这…]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket-push]]></title>
    <url>%2F2018%2F08%2F15%2Fwebsocket-push%2F</url>
    <content type="text"><![CDATA[刚听到这个需求的时候，好慌…之前没做过，该怎么办？ plan A我的大脑迅速闪过一个方案：收到信息就在右上方弹出消息块，然后过个五秒，就把自己删除。接着我去查：react如何把自己删除，得到的答案是：移除组件必须是父组件去移除。此计划不行，怎么办？ 接着我继续想，不行啊，我得记录之前的消息，要是两秒内来个三条消息，新的就把旧的遮住了… plan A over了，plan B此时，我想到了一个package：react-s-alert，这个组件可以满足我的需求呢，但是，我如何自定义我的消息块，只有一个message的选项，可是我的消息块类型有好几种呢，我难道要去拼接字符串？仔细想想，不可以呀，都用react了，得用组件啊，但是看了参数，好像没找到解决办法。仔细想了想，嗯，我要的核心是和它一样的，这样我改改view层，就可以用了，此方法可行。于是我fork、clone，开始仔细看源码…. 哇，这个组件内部实现了一个迷你的redux，好酷，看不懂呢，我查的时候，看到了一个叫React小书，里面有一部分是主要讲这个的，看了讲解，能稍微看懂了。于是我知道这个组件的内部的大概逻辑。仔细想了想，我是写一个插件块呢还是拼接字符串快呢？目前的阶段先用拼接字符串吧。 项目内部已经使用salert来作为全局的弹框了，我要是还用它来显示消息块，这个组件是使用一个store，这会影响我的消息块的显示！！这个时候，我还在认真的想着怎么去解决这个问题…. 终极解决方案忽然灵机一动，这不就是把东西存到store里面，展示成一个列表嘛！！！唯一多出的东西就是在每个item内部加一个timeout，显示几秒后，移除。这个时候忽然想到这个终极的解决办法的我，真的是！！！ 为什么是这样的一个心理活动仔细分析了我的全部心理活动，为什么这个解决方案如此常见，我没有想到呢！！刚开始一听到实时推送，没听过，听起来很高级呢，很难吧…于是自己把自己吓住了，人在不清醒的状况下，无法正常的思考问题…于是我开始了一系列的plan，绕了一圈才想到正常的方法。只是当我想到最后的方案时，但是带给我的冲击太大了，就是 乱花渐欲迷人眼， 我的眼睛被迷住了，当清醒的那一刻…. 过程还是不错的，我学到了如何构建一个mini的redux，现在需要努力的是：如何在大脑不清醒的状态下进行思考…多玩玩恐怖的密室逃脱 PS: 炒鸡推荐一款游戏 human resource machine，希望我没写错吧，这款的游戏对于我来说是锻炼算法和逻辑能力的，仔细画流程图还是能找到解决办法…解可能不是最优解，去搜搜最优解， 有对比才有爱❤️]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular_1_source_code]]></title>
    <url>%2F2018%2F08%2F13%2Fangular-1-source-code%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[translate-mindset-lessons-from-a-year-with-react]]></title>
    <url>%2F2018%2F08%2F10%2Ftranslate-mindset-lessons-from-a-year-with-react%2F</url>
    <content type="text"><![CDATA[前原文链接在M站经常能看到优秀的文章，昨天看到的一篇文章今天在看公众号推荐的文章中，就看到了这篇文章的译文。我看英文文章也是边看边翻译，阅读后的记忆不深，有时候还需要再看一遍，萌发了翻译的念头，先尝试一下！ 使用react工作一年后，我学到了最重要的一课我不想加这张图片，但是我知道它会引起你的注意(hhh 确实很引人注意)🔪 从一门新技术开始可能会得常麻烦，你经常发现你自己处于教程和文章的海洋中，后面是数以百万计的个人观点，每一个人都说他们找到了正确而完美的解决办法。 这些会让我们纠结我们选择的教程是否是浪费时间。 在去知识的海洋中之前，我们必须理解技术的基本概念。接着我们需要开发一种基于技术的思维模式。如果我们开始学习react，我们首先对react进行思考。只有在以后我们才开始将各种心态融合成一体。 在这篇文章中，我将从我个人使用react的经历中介绍我从这方面学到一些经验教训。我们在白天工作，晚上写个人的项目，甚至会谈一些我在本地JavaScript活动。 那么，就让我们开始吧！ react正在发展，你必须是更新到最新版本如果你还记得版本16.3.0的初始公告，你会记得每个人对此都很兴奋。 这是新版的的一些变化和改进： Official Context API createRef API forwardRef API StrictMode Component Lifecycle Changes react core团队和所有的贡献者都在你鼓励的改进我们喜欢的技术。 在版本16.4.0中，我们看到了Pointer Events。 肯定还有更近一步的改变，这只是时间的问题，异步渲染、缓存 版本17.0.0 以及其他很多不知道的改变。 因此，如果你想成为最棒的专家，你必须了解社区中发生的事情。 了解它们是怎么工作的以及它们为何被开发出来。学习正在解决的问题以及如何使开发更容易。这些真的对你很有帮助。 不要害怕将代码分成更小的块react是基于组件的。所以你应该利用这个概念，不必害怕将更大的部分分成更小的部分。有时候一个简单的组件可能只是4-5行代码，在某些情况下，它完全没问题。这样做，如果来一个新人，他们将不需要几天去了解一切是如果运作的。 // isn't this easy to understand? return ( [ &lt;ChangeButton onClick={this.changeUserApprovalStatus} text="Let’s switch it!" />, &lt;UserInformation status={status}/> ] ); 你不必制作内置复杂的逻辑组件。它们仅仅能看变量名就能理解组件。如果这样可以提高代码的可读性和测试性，并进一步减少更深一步的代码味道，那它对于团队里的每个人都是一个胜利。 import ErrorMessage from './ErrorMessage'; const NotFound = () => ( &lt;ErrorMessage title="Oops! Page not found." message="The page you are looking for does not exist!" className="test_404-page" /> ); 在上面的例子中，属性是静态的。所以我们可以有一个负责网站错误信息的pure component：NOTFound，仅此而已。 另外，如果你不喜欢在任何地方都使用css类作为类名，我建议使用样式化组件。这可以提高可读性。 如果害怕创造一个新的组件而污染你的文件夹，请重新思考如果构建代码。我一直在使用fractal structure，它很棒。 不要拘泥于基础-要变的先进有时你可能认为你不够了解一些东西而转向高级的东西。但通常你不必过于担心：接受挑战并证明自己错误。 通过掌握高级的主题来提高自己，你可以理解更多基础的东西并且如何将它们应用于更大的事情上。 你可以去探索以下很多模式： Compound Components High Order Components Render Props Smart/Dumb Components many others (try out Profiling) 探索他们，你将会知道使用它们的原因和地方。你会对React感到更舒适。 // looks like magic? // it's not that hard when you just try render() { const children = React.Children.map(this.props.children, (child, index) => { return React.cloneElement(child, { onSelect: () => this.props.onTabSelect(index) }); }); return children; } 并且，你不要害怕在你的工作中尝试一些新的事物，当然，在某些范围内。不要只限于在私人的项目中试验。别人可能会提问问题，这些都是正常的。你的任务是用强有力的论据来捍卫你的工作和决定。 你的目标应该是解决现有问题，进一步开发，或者只是提高代码质量（原文是：or just clean some pasta in the code. 我找了pasta code的意思，它与以下的名词有关：SpaghettiCode、RavioliCode、LasagnaCode），即使你的建议被拒绝了，你应该回家去了解，而不是沉默。 不要过于复杂这个听起来像一个反驳论点，但是它有所不同。在生活中，无处不在，我们必须保持平衡。我们不应该过于炫耀（over-engineer to show off）。我们必须务实。编写容易理解并实现其目的的代码。 如果你不需要redux，但是你想要使用它因为每个人都在不知道它的真正目的而使用它，不要这样，提出意见，如果别人推你，不要害怕站起来。 有时候你也许会想使用最新的技术编写复杂的代码，你就可以向世界说：我不是一个初学者，我正在成为一个中级，看看我能做些什么。 说实话，这是我在开发之旅开始的心态。但是随着时间的推移，你会理解不带有炫耀编写代码，因为‘它能工作’是最容易使用。 同事可以处理你的项目，你不是唯一负责开发、修复、测试的人。 团队可以在不参加长时间的会议了解其他人的所作所为。几分钟就足够用来讨论了。 当你的同事出去度假两周时，你可以接管他们的任务，而且你不需要工作8小时，因为它可以在一小时内完成。人们尊重让别人生活更轻松的人。 因此，如果您的目标是获得尊重，提升排名并进行改进，则需要为团队而不是自己编写代码。你将成为每个人最喜欢的团队成员。 重构，重构和重构 - 这是正常的尽管项目经理会经常改变他们的想法，你改变主意十几次。其他人会批评你的工作，你也会批评它。因此，你必须多次改变你的代码。不要担心，这是一个自然的学习过程。没有失败和错误你不能提高。我们倒下的次数越多，恢复起来就越容易。 但这里有一个提示：确保测试当前的软件。 Smoke、unit、integration、snapshot，不要害羞使用它们。 每个人都面临或将面临这个场景：测试可以节省宝贵的时间。如果你像许多人一样认为他们浪费时间，那就试着思考一下。 你不必和你的同事一起解释事情是如何运作的。 你不必和你的同事一起解释为什么事情会破裂。 您不必为您的同事修复错误。 您不必修复3周后发现的错误。 你将有时间做你想要的东西。 这都是非常有益处的。 如果你喜欢它，你会茁壮成长。在过去的一年里，我的目标是在React上做得更好。 我想谈谈它。 我希望别人和我一起享受。我可以不停地坐着整夜编码，看着各种各样的谈话，享受它的每一分钟。 问题是，如果你想要什么，不知怎的，每个人都开始帮助你。上个月，我面对200人发表了我的第一次React演讲。 在这一年期间，我变得更强大，更舒适地面对react的多种模式、范式和内部运作。我可以进行高级讨论并向其他人讲授我不敢触及的话题。而今天我仍然感受到一年前我所感受到的同样的兴奋和享受。 所以我建议每个人都问自己：“你喜欢你做什么吗？”，如果没有，继续寻找你可以谈论几个小时的特殊的一块，每晚学习，变得开心。因为我们必须找到最接近我们心灵的东西。 不能强迫成功，它必须实现。 如果我可以回到一年的时间，那么在我前面的旅程之前，我会为自己做些准备。 谢谢你的阅读！ 如果你觉得这篇文章对你有帮助，请鼓掌。 后不尝试不知道！翻译过程中，我只能看懂一句话表达的意思，但是翻译出来需要稍微润色一下。对于我看不懂的句子，我尝试google translate，效果还是很好的😂。对于里面的一些通用名词我还是不太了解：例如 pasta code、code smell，需要我再去查一遍，有时候可能自己也是看的懵里懵懂的。第一次翻译之旅真的是太累了，我需要大量的时间去找一些专业名词，进而才会理解作者要表达的意思，但有时候翻译出来还是很晦涩。这次真真正正的感受到翻译者的不易，感谢我曾经看过的翻译文章的作者，也深深了解到我司编辑的压力。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap-modal]]></title>
    <url>%2F2018%2F08%2F08%2Fbootstrap-modal%2F</url>
    <content type="text"><![CDATA[之前看bootstrap的modal的时候，当modal打开时，动态为body增加padding-right: 15px的style，刚开始时有点疑惑为什么不直接给open-modal增加padding-right: 15px，还非要动态增加呢？ 由于现在的项目中也有modal，我是采取的第二个方案，通过class给body增加样式。由于我的chrome的滚动条是需要占空间的，emmm，打开modal，样式是ok的，但是测试给我说，打开modal的时候页面整体会移动，很疑惑，看了他的浏览器，发现浏览器的滚动条是不占宽度的，所以当打开modal的时候，给body增加padding-right导致页面右移。 这个时候，我赶紧去看bootstrap的源码： // modal.js Modal.prototype.show = function (_relatedTarget) { // ..... this.checkScrollbar() this.setScrollbar() this.$body.addClass('modal-open') // ..... } Modal.prototype.checkScrollbar = function () { var fullWindowWidth = window.innerWidth if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8 var documentElementRect = document.documentElement.getBoundingClientRect() fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left) } this.bodyIsOverflowing = document.body.clientWidth &lt; fullWindowWidth this.scrollbarWidth = this.measureScrollbar() // 得到scoll bar的宽度 } Modal.prototype.measureScrollbar = function () { // thx walsh var scrollDiv = document.createElement('div') scrollDiv.className = 'modal-scrollbar-measure' this.$body.append(scrollDiv) var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth this.$body[0].removeChild(scrollDiv) return scrollbarWidth } Modal.prototype.setScrollbar = function () { // 为body动态增加padding-right var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10) this.originalBodyPad = document.body.style.paddingRight || '' if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth) } // 注： 如果没有对body的宽度做设置 // fullWindowWidth - document.body.clientWidth也可以得到scrollbar的宽度 每次打开modal的时候，动态的计算一下scrollbar的宽度，宽度即为padding-right的值。关闭modal的时候清空style的值即可。 扩展 先去增加body的style，再增加class，在写的过程中，我一直得到scrollbar的width为0，我还想着是不是异步的计算，检查了代码以后，发现是先加class再计算才导致每次计算为0。 我测试了Chrome、firefox、safari三个浏览器，scrollbar的width都是15，看的资料说scrollbar的width一般在14-18之间… 我检索了一下：如何隐藏chrome的滚动条，得到的答案是： chrome://flags/#overlay-scrollbars，我去找这个设置的时候，发现已经找不到这个设置了…..]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data-flow]]></title>
    <url>%2F2018%2F08%2F05%2Fdata-flow%2F</url>
    <content type="text"><![CDATA[前话，我最开始接触的是Angular，再是Vue，工作之后就开始用React，之前习惯了双向数据绑定，刚开始写太顺手，但心中想着框架是相通的，于是抱着这个想法，继续下去，遗憾的是，我把不相通的地方当成了相通….最明显的例子应该就是父子组件因为数据而产生的通信 双向数据流对于angular来说，对于同一份数据，我既在父组件中可以进行更改，也可以在子组件中进行更改，通信功能其实很弱化。 单向数据流对于父组件中的数据，子组件如果有修改的需求，该怎么办？在查到的资料中，很多解决方案都提到了调用这个词，父组件调用子组件的方法，子组件调用父组件的方法。抱着这样的想法我会写出以下： const Parent = () => { return &lt;MyChild {...someFunc}/> }; class MyChild extends React.Component { delete(id) { // $.ajax this.props.someFunc(); } render() { return ( // ) } } 写了很久的上面的解决方案….即是单向数据流，子组件调用了父组件的方法，我在调试的时候，假如看到数据的变化，我还需要去子组件里面查找，而且最典型的是对于一个数据的处理发生在了两个组件之间。这违背了单向数据流的思想。于是，第二个解决方案来了： class Parent extends React.Component { delete() { // babbababa } } const MyChild = (props) => { return ( &lt;div onClick={props.delete} ) }; 子组件变成一个纯组件，它如果想要对数据做什么，只是简单的告诉父组件，它本身没有任何的操作逻辑。所有的数据操作都发生在拥有数据的组件中。 结语：特性不相通，和特性有关的操作也不会相通的。]]></content>
      <categories>
        <category>react</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-optimization]]></title>
    <url>%2F2018%2F08%2F03%2Fcode-optimization%2F</url>
    <content type="text"><![CDATA[代码需要及时优化，但是什么的优化是恰当的呢？什么优化是不恰当的呢？ 这个时候需要优化了我有两个container： 一个具有筛选功能、一个不具有筛选功能，但是他们有共同的属性：list为空的时候，都显示没有数据；并且都具有瀑布流的功能。但针对目前只有这两个container的时候，我可以不进行相同功能的提取。但是，第三个container出来了，它与之前的两个container都不相同（数据获取的方式与前两者不同），但是具有相同的特性。在我准备写的时候，我发现再让我写一遍瀑布流的功能很别扭，这个时候，就应该考虑优化代码了。于是，我比较了这三个container的相同性之后，开始进行分层处理。 // fetch 数据层 // 解析数据层 // 判断是否与内容以及增加瀑布流功能层 // 内容显示层 分层处理后，代码的重复性减少，代码层级变得更清楚，架构也变得稳定。因为使用React去进行开发的，这样的划分带来的最显著的特点就是组件化，即使以后出现新的数据源，这样的分层也会很灵活。以上是我做的一个我觉得很棒的优化。我放下手头的活，写写画画思考了一会，经过分析得出这是最好的一个处理方式，确定好方案，撸起袖子，开始干活！ 以下优化不可取 写了好多组件，都需要用到redux里面的数据，写的mapState那叫一个重复啊，我想着把这一块相同的代码提成一个公用函数。想了就做了，结果当然是得到了反对，并乖乖的改了过去。对方给我的理由是：mapState本来就是标示从Redux里面去了哪些数据，如何命名。如果写到别的地方，阅读者不能一眼看到你想要的数据类型，反而还需要再去查别的文件，这种做法是不恰当的。 2.技术栈现在用的graphql + apollo，所以大部分组件都是以这样的格式开头的： @graphql(QUERY, { options: { variables: { // params } } }) @WaterFallWrapper() // 高阶组件 class HomeNewest extends React.Component { // bababa } 我看了很多组件都是这样开头的，心理的优化分子开始作祟，我想再把graphql弄成一个高阶函数，准备这样做的时候，我认真的思考一下🤔，这个包暴露的方法为什么不来一个最精简的方法呢，这么想了想，就没有进行这个优化工作…这个就属于过度优化了… 总结优化代码的话，最好从架构的方面去入手去进行，而不是仅仅从代码角度去思考 PS: 引用别人的话：过度优化相当想着死后如何分遗产;-)]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prime-number]]></title>
    <url>%2F2018%2F07%2F25%2Fprime-number%2F</url>
    <content type="text"><![CDATA[给定一个数字n, 打印出n以内的所有素数。素数的定义非常简单，对于一个整数，除1和它本身外，再没有其他因数了，这个数就是素数。就是说，只除以1或者本身时余数为0，除以其他数所得的余数均不为0。 最简单的方法-- 返回一个整数的所有因数 factors :: Integral a => a -> [a] factorsn=[ x | x &lt;- [1..n], mod n x == 0] > factors 24 -- out: [1,2,3,4,6,8,12,24] -- 检验一个数是否为素数的函数，只需检验它的因数是否只有1和他自己 isPrime :: Integral a => a -> Bool isPrime n = factors n == [1, n] -- 生成素数列表 primes :: Integral a => a -> [a] primes n = [x | x&lt;- [1 .. n], isPrime x] 上面的方法效率很低，每次求因数的时候，要从1～n全都遍历一遍 思考一下，可以简化一些过程 除去2以外，所有的素数都必须为奇树 素数必须是大于等于2的整数 对于一个整数N，若它有一个因数为p1，必有另外一个因子p2，使得N=p1*p1，并 并且p1与p2 一 分布在N的两端或p1 =p2 = 根号下N; 因为比2大的素数必须是奇数，所以它一 也不会有偶因数. 所以，对2进行单独讨论，然后对于其他的数只需要用它去除以所有 3 ∼ 根号下n的所有奇 数，若余数全不为0，则这个数为素数。这样，对于isPrime可以这样定义 isPrime' :: Integral a => a -> Bool isPrime' 2 = True isPrime' p = p > 1 &amp;&amp; (all (\n -> p `mod` n/=0 ) $ takeWhile(\n -> n*n &lt;= p)[3,5..]) -- 注： takeWhile (\n -> n*n &lt;= p) [3,5..]) 求出了 3 ∼ √N 的所有奇数数组成的列表 除此之外还有一个方法叫做埃拉托斯特尼筛法。给 从2开始连续的一列数，2为素数。那 么，在2之后有2 为因数的数均不为素数，可以被筛 。下一个数为3，3之后的所有为3的倍数的数就全被筛 了，因为4为2的倍数，这在第一轮中已经被筛掉了，下一个是5，依次类推，假设列表是无穷的，那么按着这个方法可以遍历所有的素数。 在看书时，阅读到这一块，就感觉真棒👍。填鸭式学习没有这样的思考过程，入门式的编程是以解决问题为主，未曾再进行思考。所以，入门加深入，会发现原来这个问题原来有如此优雅的方法。 PS: 以上出自haskell函数式编程入门]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-work]]></title>
    <url>%2F2018%2F07%2F14%2Fsummary-work%2F</url>
    <content type="text"><![CDATA[react selector最近我看到很多组件需要的redux中的值是一样的，但是，我需要为每个组件写一个mapState，我最直观的感觉是代码的重复性。于是我看了文档，在redux中的找到了一个selector的概念，看了看是可以减少我的代码重复性的。我尝试写了一个，就将这个重构工作交给同事。同事给我的说的意思是：selector可以理解成vue里面的computed。是通过计算得到一个新的值。例如： const getCurrentUser = (state) => ({ currentUser: state.info.currentUser }); 虽然上段代码需要在多个组件中出现。如果抽成一个方法，那么阅读代码的人需要再去找到这个方法才知道我实际需要的数据格式，虽然函数的名字已经很明确，但是你不清楚实际上在组件中使用的变量名。 例如： const searchSelector = { hasSearchFunction: (state) => state.info.currentUser.isBig &amp;&amp; state.info.currentUser.isSmall } 上段代码体现了selector的特点，通过计算得到一个新的值。这是一个提倡的做法。 redux store虽然这个坑我没遇到过，但是踩坑的人告诉我，不要什么东西都放在store里面，在store里面存值，是要进行一次stringfy，最直接的就是不要把不能进行stringfy的数据往store里面放。 组件大小最近在开发新功能的时候，会看到之前写的代码。我能体会得到之前组长的槽点。现在我看到组件，不光大而且里面很多if，看着就脑袋疼。React提倡组件可复用性。组件如果做到最大的复用性，最直接的方法就是组件功能单一性，这样组件可能变得非常小，最好还是把握一下度。以下代码会给你什么启示？ // ArticleItem.jsx const ArticleItem = () => { return ( &lt;div className="article-item"> &lt;div className="article-item__cover"> {/* ....content */} &lt;/div> &lt;div className="article-item__conent"> &lt;div className="article-item__content--top"> {/* ....content */} &lt;/div> &lt;div className="article-item__content--middle"> {/* ....content */} &lt;/div> {/* ....others content */} &lt;/div> {/* ....content */} &lt;/div> ); }; // ArticleItem.jsx const ArticleItem = () => { return ( &lt;div className="article-item"> &lt;ArticleItemCover /> &lt;ArticleItemContent> &lt;ArticleItemContentTop /> &lt;ArticleItemContentMiddle /> &lt;/ArticleItemContent> &lt;/div> ); }; 以上代码会给你带来不同的直观感受。阅读第一版代码，需要足够的耐心来阅读才能知道article中的内容。看第二版的代码，你可以很清晰的看到，article中到底有着什么内容。嗯，可以理解为什么别人不想看我的代码了，又臭又长！现在看来重构别人的代码也是件痛苦的事情。 闲谈之前看到很多的大神的经验谈，但是最真实的感受就是：没经历过真的很难去理解其中的意思。只有真正上手后，才能理解其中的奥妙。hhhh，是不是特别像高中的老师痛心疾首的告诉学生要好好学习，当时真的内心毫无波动，但是现在在想，会发现已经没有足够的精力对待学习这个事情了。活到老学到老，加油，你是最棒的！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[history-push-state]]></title>
    <url>%2F2018%2F07%2F13%2Fhistory-push-state%2F</url>
    <content type="text"><![CDATA[如何想要点击浏览器自带的前进 后退按钮 不刷新页面，可以通过改变history的state想了一下，写了一个小demo。 &lt;nav> &lt;a href="/home">主页&lt;/a> &lt;a href="/about">个人&lt;/a> &lt;a href="/test">测试&lt;/a> &lt;/nav> &lt;div id="content">&lt;/div> &lt;script> const baseHref = location.href; const baseUrl = '/test.html'; window.onload = () => { const links = document.querySelectorAll('a'); links.forEach(item => { item.addEventListener('click', (event) => { event.preventDefault(); const href = item.getAttribute('href'); history.pushState('', '', baseHref + href); setContentHtml(href); }); }); window.onpopstate = (event) => { // console.log(event); const currentPathname = event.target.location.pathname; const targetHref = currentPathname.split(baseUrl)[1]; setContentHtml(targetHref); } const setContentHtml = (content) => { document.getElementById('content').innerHTML = content; } // 接管路由 // 1. 得到baseUrl之后的href // 2. 根据href去render } &lt;/script> 假如你是直接打开html文件，使用history.pushState会出错，这时候你需要新开一个server。其中最主要的是，你要托管a链接的herf。其中在onpopstate中，我得到targetHref的方式，感觉有些蠢，目前还没想到好的方法。去看一下其他的框架可能会给我一个不一样的思路。飘过～ 2018-07-14 更新在history这个项目中得到的启示：history.pushState的第一个参数就是onpopstate事件中的event.state这样的话，我可以对现有的进行一些改进 // first argumens is event state // history.pushState('', '', baseHref + href); history.pushState(href, null, baseHref + href); // .... // const currentPathname = event.target.location.pathname; // const targetHref = currentPathname.split(baseUrl)[1]; const targetHref = event.state; 这样想一下，event.state里面可以存很多东西….]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>history&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rails-access-origin]]></title>
    <url>%2F2018%2F07%2F06%2Frails-access-origin%2F</url>
    <content type="text"><![CDATA[记录一下，在rails里面如何设置access-origin…. gem 'rack-cors', :require => 'rack/cors' config.middleware.insert_before 0, Rack::Cors do allow do origins '*' resource '*', :headers => :any, :methods => [:get, :post, :options] end end]]></content>
      <categories>
        <category>rails</category>
      </categories>
      <tags>
        <tag>rails</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bad-code-2]]></title>
    <url>%2F2018%2F07%2F05%2Fbad-code-2%2F</url>
    <content type="text"><![CDATA[最近的烦恼最近真的超级苦恼。一直在进行新功能的开发，没时间做我之前想要重构的东西。在进行开发的时候，这个时候我已经很注意重构的信号，新功能的开发需要重构一些代码，秉承着一个pr只做一个功能，于是我需要切换分支，提pr，合并pr之后，再进行新功能的开发，这个事情真的非常痛苦。之前没有充分的经验和思考进行的开发，给现在的我带了巨大的痛苦。 启示（都是泪）1. 每个文件的入口文件应尽可能的保持干净不要因为函数小，就要往index中塞。index是入口文件，了解整个项目从这里开始，所以要保证，这里的代码做到最简洁明了，一眼看过去，就能有一概览的感觉。小函数感觉放在一个单独的文件中太不值当的，就把所有的小函数放在一个文件中。整理之后，我感觉非常清新。 2. 多处都用到的样式，这个时候就要考虑重命名了要不看了很疑惑，这个页面为什么有其他页面的style 3.实时抽取util组件划分要清楚，例如可以抽出来api.js、tool.js 4.函数复杂度尽可能的降低若真的找不到适合的解决方法，可以与身边的人分享一下，或许会得到更好的解决办法 5. 你连续copy一段代码以上，这个时候，你可以考虑写一个工具来生成相同的代码6. 需要lazy的地方，及时lazy7. 一个问题有两个不同的解决办法，各有利弊,选择代价最小的移动端和PC端共用一个相同的组件，这个我写一个组件，写两份样式。在这个情况下，假如你修改一下组件，这个时候，你就要同时修改两份样式。一般移动端展示的UI较少，用PC端的组件，会造成很多DOM的多余。所以这个时候，写两个组件更好一点。 8.对于react的看法要学会切小片片，尽可能的组件化，组件尽可能的小，职责尽可能明确。之前写两个wrapper有一段相同的代码，这个还可以接受，等我再写一个wrapper时，发现还需要那一段相同的代码，我受不了了，于是将一个组件拆成了三层。emmmm，组件小多么重要。]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bad-code]]></title>
    <url>%2F2018%2F07%2F02%2Fbad-code%2F</url>
    <content type="text"><![CDATA[重构当你发现现有的结构满足不了现有的功能，这是重构的信号。很遗憾，为了赶进度，当这些信号出现时，你没有放在第一位去考虑，随着增量的开发，再回头准备下手重构，有一种牵一发动全身的感觉。 烂代码的由来词不达意代码写出来的目的是给人看的，一般你写的代码都不会由你维护。emmmm 随意的命名，给阅读代码的人带来巨大的负担。自己看两天的代码也会有一种雾里看花的感觉。 二随一变这个是在开发过程中，两个对象都随着一个对象变，又勤勤恳恳的写了两遍。这个时候，当发生一点变化，我要找到全部随变的代码，两个一块修改…改的手都累了，眼也花了 我就不改变参数的个数现有的函数不能满足最新的需求，哎呀，我得在往这个函数中传一个参数，emmm，好麻烦，试试能不能在现有的参数中得到我想要的参数，还可以，就这样吧。于是，开始循环，整个函数已经不堪重负了….满篇的if else 来来来 我的麻花真好看写了一个函数，哎呀，我这边需要和这个函数差不多的函数。哎呀，传一个标志，里面判断吧。这麻花不是一般的好看啊 const getData => (isAdd) { if (isAdd) { ..... } // 共用代码 if(isAdd) { ..... } // 共用代码 if (isAdd) { ..... } } repeat yourself做spa的时候，五个页面都是一个list，于是我勤勤恳恳的写了五个list。这是在做ui的时候。在接数据的时候，我发现这几个页面的整体都是一样的，唯一不同的就是里面的item是不一样的，那我为什么还要写五遍呢？其实开发的时候，就是ctrl+c和ctrl+v，那个时候还庆幸，因为把功能划分的十分清楚，我在每个页面map一遍，还挺简单的。沉浸在这种欢乐中，导致忘了这个repeat的操作。于是，动手写个一个生成list的function后，每个组件的代码两行就可以搞定了。 磨刀不误砍柴工对待一个复杂的问题，首先要勾勒出它大概的轮廓，把能想到的全列上，以此先做出一个好的架构。边写边想看是一个需要摒弃的习惯（对于我自己来说）。这次新做的搜索，我先写好ui,在接数据之前，我能大概想到是什么个情况。于是我开始下手写了。写着写着，我发现，嗯 导航需要条件，下面的list需要条件，右边的筛选也需要这个条件。筛选和list是属于一个组件中，我已经写到单独的list这一块了，有种写不下去的感觉，于是我开始将它们共用的数据全部放在父组件。这对于开发中的时间，是一个巨大的浪费，因为这意味着我之前的工作是白做的。这个时候，我开始拿起纸和笔，开始分析我应该怎么去规划…尽管我再分析的时候，把能预见的问题都想到了，但是在开发过程中还是遇到了未知的问题..写代码的仔细分析很重要….开发过程中的清晰头脑也很重要 先写到这….]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[refactor]]></title>
    <url>%2F2018%2F06%2F23%2Frefactor%2F</url>
    <content type="text"><![CDATA[闲谈最近很大一部分工作是在进行重构工作，每次都需要提一个大pr，很是心累。原本项目就是重写了一份，但是在架构方面还是没有做好。在开发过程中，没有进行总结，错过了重构的好机会，导致后期维护起来很累。编写代码的很大感觉，哎这一块我好像写过，copy过来。其实这就是一个重构的信号。don&#39;t repeat yourself.在开发过程中，我做了很多copy的工作，于是出来混总是要还的。现在重构起来就需要将凌乱的部分整合在一起。 css整理工作最近的整理工作，主要是在整理css和js，现在想想也很是惊奇。对于css的整理，是在前期没有很好的去总结组件的共同之处，导致css文件是一个增量的过程，而不是迭代的过程。意思到这点之后，我开始梳理和提取相同的地方。css的整理要注意的是：词达意和语义化，这意味着别人一看到你的class就能大概猜出来它是个什么样的。 js整理工作对于js的整理，很大一部分问题就自己否定自己。刚开始写的时候，我问自己：js可以拿redux里面的数据吗？我在没有查询的基础上给了一个自己否定的答案。嗯，不可以的话只能退而求其次了。现在有人告诉我可以，于是开始整理和重构。看起来问题是出在我没有做好准备工作上面。 什么时候进行整理我不知道这次的整理是否可以称得上重构？但是这次的整理是我的整体思路更加清晰，架构也在渐渐明了之中。在编写的过程，做好的时机是：这一块我之前写过类似的，这个时候，你就考虑把相同的地方抽出来作为一个单独的部分。还有一个情况是你写着写着写不下去了，这个时候，就需要从头梳理一下思路，到底是哪出的问题。或者是目前的代码已经不能满足新的需求时。 整理完一个item，感觉浑身清爽PS:作为一个前端来说，写出来的是直接和用户交流的产品，在开发过程中，我是在知道需求的基础上进行开发的，对于一个临时的功能，我可以写的简单一点，但是也需在明了的基础上进行，emmmm…反之，使用者已疯]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdf]]></title>
    <url>%2F2018%2F04%2F08%2Fpdf%2F</url>
    <content type="text"><![CDATA[在网页中浏览pdf文件，最简单的办法当然是插入iframe了 html5中浏览pdf文件html5中有标签可以插入pdf,但是在每个浏览器上的表现形式不一样… &lt;embed src="pdfFiles/interfaces.pdf" width="600" height="500" alt="pdf" pluginspage="http://www.adobe.com/products/acrobat/readstep2.html"> 插件pdf.jspdf.js是一个浏览器兼容的插件，移动端也很使用，有一点：需要引入的包太大。为此，有人又做了一个包裹pdf.js-viewer。这个npm是pdf.js的打包后的版本。在使用的过程中，你会发现样式不对，此时你可以将pdf.js中的viewer.scss，拷贝的你的开发目录，而不是引入pdf.js-viewer的css，里面的样式已经过时了。语言包引入后，页面就会翻译，不用做其他设置。 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;link rel="stylesheet" href="./viewer-2.css"> &lt;link type="application/l10n" href="node_modules/pdf.js-viewer/locale/zh-CN/viewer.properties" /> &lt;style> html, body { height: 100%; margin: 0; padding: 0; } body { overflow: hidden; } #pdfjs { height: 100%; } #viewBookmark, #secondaryToolbarToggle { display: none; } pdfjs-wrapper { display: block; height: 100%; } &lt;/style> &lt;/head> &lt;body> &lt;div id="pdfjs"> &lt;!--#include virtual="node_modules/pdf.js-viewer/viewer.html" --> &lt;/div> &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js">&lt;/script> &lt;script src="node_modules/pdf.js-viewer/pdf.js">&lt;/script> &lt;script type="text/javascript"> $(function() { // window.PDFJS.locale = 'zh-CN'; $('div#pdfjs').load('http://localhost:65534/viewer.html', function(res) { window.PDFJS.webViewerLoad(); window.PDFViewerApplication.open('http://localhost:65534/sample-3pp.pdf'); }); }); &lt;/script> &lt;/body> &lt;/html> 集成到webpack中测试开发可以正常使用，需要集成到webpack中。由于文件都需要用webpack打包，于是按照平常一样，将文件引入，发现控制台报错。在调试过程中，我遇到5种左右的错误，影响最深刻的一点是：document undefined…也是很迷，调试过程中，发现pdf.js种的代码执行了两遍，第二次的时候就会出这个错误。仔细翻了翻源码，在pdf.js中，它需要引入pdf.work.js文件，webpack打包时，它根本就找不到这个文件，最后的结果是只在windows上挂载了关于pdf的两个对象…最后的最后，直接在页面上引入pdf.js和pdf.work.js，由于文件过大，你按需进行加载就可以了。 最后的最后，写了很长时间的slim模版，我忘了原生的标签怎么写了…导致我在引入语言包话费个很长时间…也是很迷…切莫忘本😊]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-plugin]]></title>
    <url>%2F2018%2F03%2F13%2Fjquery-plugin%2F</url>
    <content type="text"><![CDATA[使用插件现在是使用webpack打包，yarn安装需要的插件很便捷。今天遇到了一个奇怪的问题，我使用yarn安装了一个jquery插件，使用时，jquery报错… 排错 安装、引用是否正确首先先确定一下：包是否正确安装；使用时是否正确引用；ok，这两个都是正确的 webpack是否配置正确在webpack中，一般都会将jQuery设置为全局变量，在webpack中设置如下: new webpack.ProvidePlugin({ $: "jquery", jQuery: "jquery" }) webpack版本是否合适开发中使用的是rails-webpack，其中的配置需要更改（之前对照文档修改配置，报错；今天才看到原来是版本问题😂） 最最重要的一点：查看你安装的插件的包里面有没有node_modules这个文件夹在排查错误时，我将包里面的代码拷贝到开发目录，我发现能用。。。直接引用包就不可以。使用插件，最终目的是在$这个对象上挂载方法。报错就是说明$对象上没有这个方法，问题来了，包里面的$是哪来的？全局对象还是node_modules文件夹中的jquery???引用多个插件，插件依赖的jquery版本可能不是一样的，webpack打包的时候，首先去找安装包的插件node_modules里面的jquery，局部变量覆盖全局变量。所以此时挂载方法的$对象是node_modules包中的jquery，而不是全局的$对象 为什么安装的jquery版本会不同这个时候你也许会疑问🤔️为什么会安装这么多版本？首先你要去检查依赖的jquery版本，这个时候你可以去查看yarn.lock文件，里面有具体的依赖关系。这个时候，假如按照算法，你发现几个插件依赖的jquery的版本应该是一致的。但为什么yarn计算出来的不一样呢🤔️？因为yarn在add包时，计算lock的时候，会在原来的基础上进行计算，恰好在这个时间隔中，jquery升级了…这就导致yarn计算出来的依赖版本可能有所不同此时，你可以使用yarn upgrade进行更新lock文件 如果以上步骤还不能解决问题…我也不知道根本问题是什么]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get-module]]></title>
    <url>%2F2017%2F11%2F15%2Fget-module%2F</url>
    <content type="text"><![CDATA[发送邮件: nodemailer 基本代码，使用之前请确保邮箱开启SMTP const nodemailer = require('nodemailer'); nodemailer.createTestAccount(() => { const config = { host: 'smtp.163.com', port: 465, secure: true, // true for 465, false for other ports auth: { user: 'xxxx@163.com', // generated ethereal user pass: 'xxx' // generated ethereal password } }; const transporter = nodemailer.createTransport(config); // setup email data with unicode symbols const mailOptions = { from: '"Fred Foo 👻" &lt;xxx@163.com>', // sender address to: 'xxxx@gmail.com', // list of receivers subject: 'Hello ✔', // Subject line text: 'Hello world?', // plain text body html: '&lt;b>Hello world?&lt;/b>' // html body }; // send mail with defined transport object transporter.sendMail(mailOptions, (error, info) => { if (error) { return console.log(error); } console.log('Message sent: %s', info.messageId); }); }); 若使用SSL, 在config中添加 secureConnection: true, // use SSL 3.添加附件, 在mailOptions添加 attachments: [ { filename: '文档.txt', // 不会乱码 content: '哈哈哈' }, { filename: '2.txt', content: 'heool word' } ] 添加图片, 在mailOptions添加 attachments: [ { filename: '文档.txt', content: '哈哈哈' }, { filename: '01.png', // image path: './flow.png', // 图片路径 cid: '00000001' } ]]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project]]></title>
    <url>%2F2017%2F11%2F06%2Fproject%2F</url>
    <content type="text"><![CDATA[设计图出代码根据设计图，如何写出好的代码。设计图是一张一张的出的，因为不知道哪一块会在其他的设计图中出现，于是只看到当下并不是一个好的想法。看到一张图，可以先思考一下，哪一块有可能被复用。在class的命名上就会有所改变…刚开始一个元素在主页出现，我可以给它命名home__XX，但是当这个元素也在文章页面出现时，再起一个class，重复写一样的css，这不是一个好的想法，但是将这个类名直接写在文章页，看着又很不爽。在项目中，使用scss用来开发，这个时候，你可以改变类名或者使用@include和@extend来组织代码。js部分，不止实现功能，也要保证优雅。例如一个参数可能是数组或者string，你可以这样写： if (typeof argument === 'string') { //... } else if (typeof argument === 'object') { //... } 也可以这样 const map = { string: () => { //... }, object: () => { //... } }; return map[typeof argument](); 文件夹组织根据项目需要组织出合适的文件结构，文件名也要更好的表达出这个文件夹中的内容，使之清晰… 重构开发的过程中，代码量越来越大，这时候可以考虑一下代码的重构。重构是不大幅度改变代码的基础上进行的…大幅度的重构甚至重写不能称作重构…推荐书籍：重构:改善既有代码的设计]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2]]></title>
    <url>%2F2017%2F09%2F13%2Fpm2%2F</url>
    <content type="text"><![CDATA[由来嘤嘤，看到ruby中有一个gem叫做capistrano， 使用它可以实现一键部署到服务器上了。之前在懵里懵懂的时候，做了一个网站，每次更改后，我都用filezilla将新版本的代码上传，再restart项目，超级费劲。看到ruby后，于是赶紧去网上搜了搜，pm2可以做这件事。之前也见到过pm2，那时候我在寻求守护进程的module，但是我选择了forever。 使用pm2实现自动部署这个链接对我的帮助很大，基本上按照他的步骤来应该是可以实现自动化部署。 出现的问题服务器上的node是我很久之前安装的，但是pm2要求使用nvm，于是装了nvm，但是到了“克隆好之后执行安装和启动”，这一步报错：npm 这个命令找不到。去寻找解决办法，有的说将.bashrc文件中的关于nvm的部分放在最上面，还有的说要使用nvm重新安装node，这两个方法都试了，但是都没有解决错误。于是我只能去pm2的目录中的source文件夹，手动去执行npm install 和 pm2 start app.js 等待update得到解决方案： nginx转发最暴力的方法就是下面👇的代码： server{ listen 80; server_name xxx.xxx.xxx;(域名) location / { proxy_pass http://127.0.0.1:3000 } } 目前可以解决我的需要，假如还有其他的端口需要监听该怎么办？]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-first]]></title>
    <url>%2F2017%2F09%2F13%2Flinux-first%2F</url>
    <content type="text"><![CDATA[对待自己的服务器，想着反正也没人攻击，也就从来没在意过。前天得到了一个讯号：要好好对待服务器，第一步就是安全性， 你需要这么做 使用root账户登录后，创建一个用户并设置密码，如果有必要，就赋予用户root权限 上传ssh-key，上传成功后，你就不用输入密码登录服务器了 关闭密码登录，打开ssh-key登录 以后就使用你新建的用户登录吧]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week6]]></title>
    <url>%2F2017%2F09%2F03%2Fweek6%2F</url>
    <content type="text"><![CDATA[举一个栗子🌰：在分页时，你通常会看到url上一般是xxx?page=1通常的做法是点击第几页直接跳转页面，是通过location进行的现在的需求是：在跳转页面的时候，我既想要改变url，同时我只需要改变分页的数据，而不需要整个页面重绘。 —–很幸运history提供了这么一个方法pushState，它有三个参数：state object，title，以及一个可选的URL地址。第二个参数title:现在firefox和chrome已经忽略该参数 window.history.pushState('','title','?page=1'); pushState参考链接]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coursera-3]]></title>
    <url>%2F2017%2F09%2F03%2Fcoursera-3%2F</url>
    <content type="text"><![CDATA[淡淡的忧伤three time 是三倍的意思 学习一门新的语言目前学习一门新的语言仅仅停留在Syntax，但是真的要把代码写的优雅，你更要了解它的Type-checking和Evalustion，了解这两者之后，你能知道代码在哪里可以优化，而不是代码的优化是在写代码中或者看到别人的代码时看到的目前这个方面需要改变，思想的转变…人的思想都是在肤浅向深沉转变😄 应用类型下面是一段java代码，乍看上去没有问题，但是使用p.getAllowesUsers[0] = p.currentUser，这一句代码使权限形同虚设。原因是：getAllowesUsers中直接返回的是allowedUsers，我尝试修改p.getAllowesUsers的值, 实际上修改了示例的私有变量的allowedUsers的值修改： 在getAllowesUsers中直接返回的是allowedUsers的一个克隆 class ProtextedResource { private Resource theResource = ...; private String[] allowedUsers = ...; public String[] getAllowesUsers () { return allowedUsers; } public String currentUser() { // ... } public void useTheResource() { for(int i = 0; i&lt; allowedUsers.length; i++) { if (currentUser().equals(allowedUsers[i])) { ... // access allowed: use it return ; } } throw new IllegalAccessException(); } } 之前在项目中，我定义了一个default的值，合并对象选的是lodash的extend,因为没有看文档就直接使用了，extend(default, options)，发生了bug。我的本意是default是一个不可变的值，它作为一个函数的默认值。经过长时间😅的调试，我发现default的值改变了，去看文档发现extend会改变第一个参数的值。于是更改为extend({}, default, options)当应用类型作为函数的参数，一定要特别注意，尽量使用实参的clone值，要不在函数中修改参数的值，就相当于修改实参的值了… 尾递归递归在一定程度上可以代替loop，一方面它看起来更优雅，另一方面…下面的代码上面的函数是我们经常使用的方式，通俗易懂。下面的递归称为尾递归。两种函数实现的功能相同。但是若要分析到stack处，你会发现下面的函数比上面的函数有更好的性能；首先上面的函数涉及到每次递归都要去进栈和出栈后才能得到就过，但是下面的函数却没有这样的操作。而且在Evalustion阶段，上方的函数最终结果的数据类型需要依赖上一步的结果；下面的函数时不需要上一步的计算结果 fun sum1 xs = case xs of [] => 0 | i::xs’ => i + sum1 xs’ (* tail recursion*) fun sum2 xs = let fun f (xs,acc) = case xs of [] => acc | i::xs’ => f(xs’,i+acc) in f(xs,0) end 就到这吧…😪]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week5]]></title>
    <url>%2F2017%2F08%2F26%2Fweek5%2F</url>
    <content type="text"><![CDATA[上周没写总结… if条件什么时候为false因为react共用组件，但是传过来的值的结构不同，于是使用||来进行判断选择，于是写了以下代码放心的提上去了 const count = node.count || node.usage_count || node.total_count 发现报total_count是undefined，这个我仔细看了代码没找出来哪错了，于是把生产环境的数据库拿下来，开始调试…最后发现因为usage_count的值为零的时候，会继续往后执行，因为node.usage_count值为0，js会认为是false…我的原意是为undefined的时候，会继续向后执行。使用js很随便，但是忘记了随便的副作用。于是我只能用if…else…去判断undefined了👉当if语句中的变量为false，0，NaN，空字符串，null，undefined时，判断结果为假; 图片是使用背景图还是img标签一般来说，我的习惯是图片一般使用img标签插入页面。但是，假如一个网站有中文英文两个版本，通过类名的切换而不是跳转页面可以实现中英文的切换，这个时候，就不要img标签，而是背景图的形式插入图片，这样做的好处是：图片是在css设置的，我可以为元素设置不同的类名进而切换图片 BEM不应该嵌套太深BEM命名的方式，一般是一个block里面包含element,所以我是一个block一层来的。大哥告诉我这样是不对的，划分block没有错，但是在命名不冲突的情况下，block中的element的类名没有必要一定按照block的类名开头。 一定要选好元素之前做tab切换的时候，咋改都没达到想要的效果。看了大哥的代码，才发现自己选错元素了。应该选择section的父元素而不是每个section…写代码之前没有经过严密的思考，遇到错误时，思想受到了限制，导致没想到正确的方向去… calccss3中的calc这个计算属性超级好用，但是有一点需要注意 height: calc(100%-75px); 以上代码不起作用，让人摸不着头脑，经过查询之后，需要注意的是-号两边要有空格 height: calc(100% - 75px); display:flex;兼容性网站要兼容到IE9，而flex是从ie10兼容的。找hack但是没有只对IE9起作用的hack…唉，使用\9的hack，它也在IE10下起作用对于IE9的兼容，我一般使用display: table;和display: table-cell;。此时你在设置子元素的margin是不起作用的，此时你想要的效果这两个css属性可以达到你的需求border-collapse: separate;、border-spacing: 5rem。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week5-1]]></title>
    <url>%2F2017%2F08%2F26%2Fcoursera-2%2F</url>
    <content type="text"><![CDATA[说在前面的话最初对待语言的看法：相比语言更重要的是由编程思想，语言只是一种工具。所以对于只停留在Syntax阶段，没有去深究语言的内在。之前在学习C++的时候，老师也讲过一些内存方面…例如一段很简单的代码，在C++中会造成死循环…代码片段我还是没找到…在学编译原理的时候，也学过词法分析、语法树等等…但是总是来说对于语言还是又一个模糊的概念近期在coursera看一门课程，收获很大。刚开始看视频，因为自己的英语能力薄弱，刚开始看的时候，恨不得每句话都Google tanslate一遍，看多了就习惯了，因为大部分的术语你已经知道意思了，所以能知道大概的意思。Google翻译的意思，因为不知道术语所以翻译出来也很奇特。目前是以ML为例讲解的 variable binding变量的绑定主要包括两个环境：静态环境记录了变量的类型；动态环境记录了变量的值 val x = 34 (* static env : x : int *) (* dynamic env : x -> 34 *) rules to expressions它共有三个部分：语法检查、类型检查和评估规则 Syntax: if el then e2 else e3 where if, then, and else are keywords and e1, e2, and e3 are subespressions Type-checking: first el must have bool type e2 and e3 can hav any type(let`s call it t), but they must have the same type t the type of the entire expression is also t Evalustion rules: first evalustion el to a value call it v1 if it`s true, evaluate e2 and that result is the whole expression`s result else, evaluate e3 and that result is the whole expression`s result shadowing当你重复声明相同的变量时，之前声明的值就会被覆盖，当你在REPL中看它的值的时候，就会变成hidden value，所以不建议重复声明变量 val x = 34 val x = 45 (* this is not assiginment statement *) 递归ML语言没有for循环，所以在对于list类型的数据，会尝试使用递归去解决问题，但是小心哦，不恰当的使用递归，会使运行次数呈指数式增长。下面是求list中的最大值，可以简单粗暴的理解成求数组中的最大值 fun bad_max(numbers: int list) = if null numbers then 0 else if null tl numbers then hd numbers else if hd numbers > bad_max(tl numbers) then hd numbers else bad_max(tl numbers) 上面代码逻辑清晰，通俗易懂，但是使用的时候，假如数组中的数是从大到小排列时，程序运行速度很快；相反，数组中的数若是从小到大排列，当数组是[1,…30]时，你就会发现有延迟…讲师用了一张图给你讲解 优化的方法是：你可以将bad_max(tl numbers)的值赋予一个变量，这样，每次程序运行时bad_max(tl numbers)只会执行一遍。这里使用了let...in...end，在这个课程中，作者也讲解了作用域的问题，例如子作用域的值回覆盖父作用域的值… 关键字每门语言都会提供关键字来提高代码的可读性，在适当的地方记得使用 调试错误调试错误时，一定要有耐心…]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4]]></title>
    <url>%2F2017%2F08%2F20%2Fweek4%2F</url>
    <content type="text"><![CDATA[只想睡觉...]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm-package]]></title>
    <url>%2F2017%2F08%2F17%2Fnpm-package%2F</url>
    <content type="text"><![CDATA[写包的初衷项目中很多地方用到相同的代码段，做其他项目的时候，也会用到这个功能，于是，大哥让我写一个包，供目前以及以后的项目使用 提供的功能在机器之心这个页面，上面的nav会根据滚动条的位置进而改变active状态，同时，点击nav中的每个链接，页面也会滚动到相应的section。这个功能很常见。目前，包提供的两种形式： 使用锚链接：你通过点击nav中的链接，通过锚点来使页面滚动到相应的section；同时，滚动条的位置改变时，会更改页面的hash，nav的active也会改变。 使用点击事件：你通过点击nav中的链接，通过获得元素的data-index来确定相应的section，所以你必须为nav中的item添加data-index属性；同时，滚动条的位置改变时，nav的active也会改变。 项目的地址点击这去仓库具体的参数请查看readme 项目发布的过程 新建一个文件夹，npm init来填写包的信息 编写代码 完成代码编写，若你使用ES6或者ES7的语法，需要使用babel转换一下 npm login npm publish 到这你的包发布成功，若更新包，记得要改package.json中的version 遇到的坑 完成代码编写后，直接发布了，使用的时候报错：import那报错；我以为是因为没有因为代码压缩，于是进行了代码的压缩，发现并没有什么软用；因为项目使用webpack打包，就想是不是因为没有打包，于是就开始了打包，结果项目还是报错。边上网边查，我还以为是代码写错了…；最后，看了其他包的样子，发现是使用babel打包的，解决了这个大问题。 若你安装不上一个包，报错说是因为名字重复了：不是文件夹的名字和包的名字重复了，而是你的项目的package.json中的name和包的名字重复了… 自己坑自己，代码变量拼写错误，最近老是犯这个错误😔 终结～]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7-decorator]]></title>
    <url>%2F2017%2F08%2F13%2FES7-decorator%2F</url>
    <content type="text"><![CDATA[装饰模式对于装饰模式，现在还剩下鸡腿堡+香菜+辣椒的记忆。这个是装饰模式的一个例子：有一个汉堡的抽象构件，鸡腿堡是具体构件，香菜和辣椒都是具体的装饰角色。现在我想计算鸡腿堡+香菜+辣椒的价格 针对的问题你想要动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。何时使用： 需要扩展一个类的功能，或给一个类增加附加责任。 需要动态的给一个对象增加功能，这些功能可以再动态地撤销。 需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实。 es7中的装饰器es7新增的decorator 属性，它借鉴自 Python，在 Python 里，decorator 实际上是一个 wrapper，它作用于一个目标函数，对这个目标函数做一些额外的操作，然后返回一个新的函数。 装饰propertyES2016装饰器是一个返回函数的表达式，可以将target，name和property描述符作为参数。你可以通过在装饰器前加一个“@”字符来应用它，并将其放置在您想要装饰的顶部。可以为类或属性定义装饰器。 class Cat { meow() { return `${this.name} say meow`; } } // 如果给meow方法加上可读属性 // 定义一个装饰器 function readonly (target, name, descriptor) { descriptor.writeable = false; return descriptor; } class Cat { @readonly meow() { return `${this.name} say meow`; } } // 此时你尝试修改meow，就会报错 // // 在这里推荐一个module： core-decorators 装饰class在这种情况下，装饰器将使用目标target的构造函数。 function hero(target) { target.isHero = true } @hero class MyHero {} console.log(MyHero.isHero); // true 还可以进一步扩展，为装饰功能提供参数。 function hero(isHero) { return function(target) { target.isHero = isHero; } } // 你可以写成ES6的形式 // const hero = isHero => target => target.isHero = isHero; @hero(false) class MyHero {} console.log(MyHero.isHero); // false 参考参考链接]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3]]></title>
    <url>%2F2017%2F08%2F13%2Fweek3%2F</url>
    <content type="text"><![CDATA[❓psd转html首先你拿到设计图应该做什么？我的做法是浏览一下整个页面，找出每个模块的共同点。之后开始搭建html，再写css，最后写js。昨天拿到设计图，按照这样的模式去做。可是在最后添加icon时犯了难，因为在icon库里面没有找到合适的，就想着在psd中直接导出icon，可是这时候去看psd的时候，发现整个模块是一个图层，这个时候犯了难，我不知道设计者这样做的意图？再接着我将整个模块作为一个png导出，直接放在页面上，我感觉这样做是不对的，最后的方法是将需要的图标裁剪出来，多个图标但在一个png中。这次给我一个提示：你拿到设计图第一件事是需要干什么？浏览页面的时候，是不是需要将每个模块的所在的图层全都要过一遍以及注意事项… ❓一个带有渐变颜色的圆形边框首先为了使div带有渐变颜色的边框，于是设置它的border-image是一个渐变颜色，虽然边框是渐变的了，当时它没有圆角，即使再改变它的border-radius也不会有作用。👉我在stackoverflow上找到了解决方法点击这里。但是这种实现还是有个缺点，就是div必须设置一个背景色，进而来掩盖它的after伪元素的背景色。但是我想要的效果是它的背景色是透明的，没有找到好的解决办法，就找了一个和背景色相近的颜色去代替😔。这个偷懒的方法，期待完美的解决方案… ❓css画出文件夹📁的轮廓这个问题最难的部分是画出文件夹📁上方那个弧度，没有什么好的办法，就是用两个元素的border-radius连接而成，理所当然的，画出的轮廓有些奇怪…因为border-radius越大，边框的弧度久越大，可见的border宽度会越来越窄，所以会有一种不圆滑的感觉。感觉我的想法有些奇怪… 如何做出宽高成比例的div父容器设置width和padding，padding设置百分比，padding设置百分比之后和width相关。子容器飘在父容器上width和height等于父容器即可。 ❓es7装饰器大哥说：没有什么是包不能解决的。查看了代码是使用了装饰器。 js中的offsetTop和jq中的offset()、position()使用起来还是不等同的，具体的得去查看源码… rails on ruby在查询的时候，能进行include的就不要在jbuilder里面再去查询一遍。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2]]></title>
    <url>%2F2017%2F08%2F05%2Fweek2%2F</url>
    <content type="text"><![CDATA[分页插件写分页插件，我开始的想法是： 判断是否显示“上一页” 判断是否显示“第一页” 判断是否显示“…”、”current-2”、”current-1” 判断是否显示 current页面 判断是否显示”current+1”、”current+2”、“…” 判断是否显示“最后一页” 判断是否显示“最后一页” 我的目的是最少要显示cuurent周围的四个number，按照这个想法写出来，当cuurent为1时，只会显示123三个number，而我的预期是现实12345这五个number😔调整一下做法，将上面的3-5合并，left和right表示current-2和current+2，在left&lt;0时候，将right加上left的相反数，right&gt;total同理最后，我还是找了一个插件用在项目中，👉插件的名字是：react-paginate，css部分需要你自己去写… react and jquery目前有一个container的组件，它的子组件是list和detail，list的子组件是item，点击item，detail组件会显示，显示效果是通过增加删除类名实现的。想着组件传值比较麻烦，于是就在方法里面直接使用jq早啊道元素控制。大哥告诉我，这个解决办法是不推荐的。👉正确的做法是使用state。通过改变state的值，进而改变元素的class。 redis还记得之前的一个面试问题：视频有最热视频、点赞最多视频、其他视频，每次去服务器要十个数据…由于用户使用量很多，每次去数据库查询，访问量太大。这样的话，👉可以使用redis去做缓存，这样取数据库可以直接取缓存中取，设置一个时间去更新redis即可。现在又一个需求，是记录每天用户登录网站的数量。👉方法一：给用户表增加一个最后登录时间的列，每天定时执行程序，统计一下最后登录时间是昨天的用户数量。这个方法中，选择什么时候去执行程序很重要，要不然就会有漏网之鱼。👉方法二：最粗暴的办法是，在redis中创建一个字段，它是一个数组，每次知道用户登录的时候，就将用户的idpush进数组，每天用户的登录的数量，直接通过数组的长度就可以得到。这个方法的缺点就是：用户的id字段也是一串很长的字符串，数组会特别大。👉方法三：在redis中创建一个字段，它是一个字符串，默认是长度是用户的数量的0，若用户登录，就将对应的位置为1。在这三个方法中，第三个方法是最优方法。还有一个可以做缓存的数据库叫memcache，它和redis的区别就是，redis可以持久化。 插件js-base64Graphql中自带的分页，after字段是base64的字符串。前端传值就需要将数字转化成base64位的字符串。 import { Base64 } from &#39;js-base64&#39;; const cursor = Base64.encode(number); 最后说句题外话，任何炒作都不能改变一个东西没落的事实，与其去炒作，还不如用脑子把东西做的更好。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[douban]]></title>
    <url>%2F2017%2F08%2F02%2Fdouban%2F</url>
    <content type="text"><![CDATA[在千里码刷题的时候看到了这个题目题目要求是爬取豆瓣评分最高的250部电影的总分… 分析爬数据，首先是实用http模块去爬取全部的HTML然后使用cheerio去得到HTML中自己想要的数据最后每页得到的总分相加 题目中的坑1、因为豆瓣是https开头，使用https模块，具体的方法没看，使用还是按照http模块来的2、如果按照正常的逻辑去写代码，最后得到的总分是0，因为https抓取数据是异步进行的3、使用promise来进行处理，首先需要等到25页的数据全部抓取完毕，再进行计算总分，这时候想到了promise.all这个方法。4、第一次尝试将使用promise，我在getData中直接将resolve(res)，等到下面使用的时候，res又是一个异步执行，这下尴尬😅了，于是调整顺序，在res执行end事件的时候再resolve5、js中浮点类型计算的坑，我直接暴力的*10，最后在／10 代码爬评分时，顺便把电影名也爬下来了，我准备把没看的都补上😄 const https = require('https') const cheerio = require('cheerio') let sumScore = 0 let allMovie = [] function filterMovie(html) { let $ = cheerio.load(html) let movieList = $('.grid_view li') let total = 0 let movies = [] movieList.each(function(index, item) { let score = $(item).find('.bd .rating_num').text() let movieName = $(item).find('.hd a').text().replace(/\s+/g,"") movies.push({ name: movieName, score }) total += Number(score) * 10 }) return { total, movies } } function getData(url) { return new Promise(function(resolve, reject) { https .get(url, function(res) { let html = '' res .on('data', function(data) { html += data }) .on('end', function() { resolve(filterMovie(html)) }) }) .on('error', function(err) { reject(err) }) }) } let funcArr = [] for(let i = 0; i &lt;= 225; i=i + 25) { let url = `https://movie.douban.com/top250?start=${i}` funcArr.push(getData(url)) } Promise .all(funcArr) .then(res => { res.forEach(list => { const { total, movies } = list sumScore += total allMovie = allMovie.concat(movies) }) console.log("总分：" + sumScore / 10) allMovie.forEach(movie => { const { name, score } = movie; console.log("评分：" + score + "，影片名：" + name) }) }) .catch(err => { console.log(err) console.log("出错了") }) 如果你有更好的想法，欢迎交流👏]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[work1]]></title>
    <url>%2F2017%2F07%2F28%2Fweek1%2F</url>
    <content type="text"><![CDATA[收获一turbolinks是一款将网站变成spa的一个插件，看到文档的的某些地方和ionic有些许相似之处，于是就将之前做webApp的疑问提了出来：打开页面刚开始进的页面是主页还是登录页？经过讨论后，👉是主页；为App添加一个拦截器，对于用户登录后才能使用的页面，进入时，首先在拦截器中判断有无用户登录…另外，两者之间还有相同的一点：都会提前缓存页面。之前做app的时候，添加了拦截器，因为app首先打开进入主页（这时候开始缓存和主页相关的页面），判断用户未登录，会重定向到用户登录页，这时候就会发生页面的闪烁，关于这个问题我没有查😶，我很暴力的加了一个spash….另外，关于支付宝账单页，数据是如何传递，数据格式如何设计，尝试去爬数据也没看到数据长什么样子的😑，于是目前的想到的方法是，👉后端每次去数据库取count条数据，在按照日期分组后，传到前端；前端的处理方式是：判断得到的第一个月数据与本地现有的最后一个月的数据时候是同年同月，如果是就concat第一个月的数据，剩下的数据直接push。 收获二在将加载更多全都迁移至react的过程中，我在大哥的基础上，比这葫芦画瓢，完成了页面的重构…但是现在有一个问题是：假如全用react去渲染，那么爬虫就爬不到数据，于是采用的方式是：render的时候，会在页面上先渲染一部分数据，剩下的就交给react来做；但是apollo目前提供的解决方案是：假如你将数据渲染到页面上时，会先查找cache中有没有数据，如果有就将数据渲染到页面上；否则发出网络请求。这意味着，只要我将插件渲染到页面上，就会发出网络请求，这一条网络请求是不需要的。因为用户可能不会浏览很多数据，于是想到的办法是：👉等用户去点击加载更多的时候，再去发送网络请求。查找apollo的文档，能想到的办法是：👉预先向cache中写去空数据，这样渲染时，在cache中找到数据，就不发送请求了，但是我不知如何写入数据😖，这是一个预留问题😞很忧伤的一个问题…待续… 收获三知道了reduce这个优雅的方法，promise也提供了这个方法…. 收获四在还原原型图时，更多的时间应该花费在如何设计HTML的结构上，再接下来再写css，最后再写js。这次做的时候，本来是设计好了还能符合要求的HTML结构，结果在写css的时候，发现现在的HTML不能达到预期，于是开始设计调整HTML，幸亏样式使用scss写的😉…还有一个，我看到排排站的元素，首先想到的不是ul&gt;li，而是直接用a标签去尝试解决… 收获五再看文档的时候，看到了一个新的名词：Vanilla JS；用Google translate翻译了叫奶味js😀，于是就去查它到底是何方神圣，原来它的另一个名字叫做javascript😅 收获六因为sublimen并没有完整配置，push上去的代码就跑不过测试。这次找到了eslint检测js的package,叫做SublimeLinter-contrib-eslingt，代码不通过有红色标识…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array的reduce方法]]></title>
    <url>%2F2017%2F07%2F28%2Freduce%2F</url>
    <content type="text"><![CDATA[初识第一次听说Array的reduce方法是在面试的时候这次看到大哥写的一个函数，里面用了reduce，哇，真的好优雅。因为代码的重复片段太多，我尝试去封装一个通用函数，没有成功。于是大哥出动了。目的是这样的：我可能需要data.user.article的值，或者需要data.article的值，或者需要data.categories.article的值，于是封装一个方法每次取到article的值。 // 封装一个函数reg，参数为belongto，传递的参数分别是：['user'] [] [categories] // 函数内部的主要代码是 return belongto.reduce((p,c) => p[c], data).article reduce文档Syntaxarr.reduce(callback[, initialValue]) 参数callback有四个参数：分别是accumulator(它是callback上一次返回的值或者是initialValue，前提是initialValue存在)、currentValue(正在使用的值)、currentIndex(正在使用的值在数组中的索引)、array(这个是循环的数组)；initialValue：用作第一次调用回调的初始值，如果不提供此参数，则第一次调用回调的初始值是数组的第一个元素。为了保证安全，最好提供这个值 tip: 当数组为空时，若提供initialValue，则最后的返回值是initialValue，否则，报错； 当数组不为空时，若提供initialValue，则循环从index为0开始；否则循环从index为1开始，accumulator此时为index为0的值。 返回值回调函数的最后的返回值 用法求数组元素的总和（告别for循环） var sum = [0, 1, 2, 3].reduce((a, b) => a + b, 0); // sum is 6 连接数组 [[0, 1], [2, 3], [4, 5]].reduce((a, b) => a.concat(b), []); // result is [0, 1, 2, 3, 4, 5] 相同元素在数组中出现几次 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; var countedNames = names.reduce( (allNames, name) => { if (name in allNames) { allNames[name]++; } else { allNames[name] = 1; } return allNames; }, {}); // countedNames is: // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[relay-apollo]]></title>
    <url>%2F2017%2F07%2F23%2Frelay-apollo%2F</url>
    <content type="text"><![CDATA[使用relay的感受初次接触relay，感觉上很臃肿，因为必须为每个组件设置container；若query层级嵌套很深，为了组件化，就必须将每一个react的component全部分开，在项目中，我写了六个组件，那么每个组件都需要container，写起来感觉满满的恶意。 使用Apollo再次接触Apollo，看了文档，感觉和relay大同小异，与relay的不同是：无需为每个component设置container，最后写一个query就ok👌了。query也可以由多个fragment组成。另外，apollo也为angularjs提供了解决方案，有点想不明白🤔，angularjs本身就是双向数据绑定，为什么要对它提供解决方案…另外，Apollo虽然自身内部集成了redux，假如你的项目中使用了redux，你可以使用redux而不用Apollo内部的redux。 relay 因为container的存在，数据划分的比较严密，你只能在当前的container访问fragment中的的属性，不能访问父或子fragment的属性。而apollo直接使用的是请求得到的Object…Apollo也可以和项目原有的redux相结合使用，relay不可以…待续…这次写的很匆忙，假如有不正确的地方，请指正，谢谢😊。]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>angularjs</tag>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F07%2F22%2Fgit%2F</url>
    <content type="text"><![CDATA[使用git想要去合并两个commit今天好不容易完成了工作，睡觉的时候突然想到还有些小瑕疵，就想改正。但是改动范围很小，不好意思在commit一次，于是就想将两次commit合并在一起，但是我没有将最新的commit推送到远程分支，就直接合并了两个commit成了一个新的commit，在推送到远程时，也没有先进行pull的动作（👉每次push之前一定要进行pull的动作），导致远程commit和我合并的commit发生冲突，最后还需要手动merge。看了一下提交记录，吓坏了，本来我想合并commit，预计的commit只会在之前的基础上多一次commit，但是现在多了三次commit，这下坏了。于是，上网查询，试了好几种办法。找到了一个很合适的办法 git reset HEAD^ --hard //彻底回退到上次提交 git push origin 分支名 -f // 强制推送到远程 这样操作以后，我的问题解决了 待续… -补充—最好不要不要强行push😕]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-relay]]></title>
    <url>%2F2017%2F07%2F22%2Freact-relay%2F</url>
    <content type="text"><![CDATA[上次写感想还是2014的时候，那个时候是老师布置的作业（尴尬)队长看到GraphQL很好，于是先拿一个功能来试手😊。前端要使用GraphQL，最简单的方法是使用ajax发送query字符串。这个方法，若query嵌套层级太深，会导致query很长，长的让人接受不了；再者，假如数据变化，需要你手动的去改变DOM。项目中使用了react，于是队长给推荐了react-relay来配合GraphQL。首先给的时间是看GraphQL和react-relay的文档，先瞄一眼relay的文档，感觉是层层嵌套，就先去看GraphQL的文档，relay的文档没有看完…😶 第一天开始在队长的鼓励下开始写relay，到了relay的官网上，看到有一个Demo，就把代码给copy下来，再根据文档理解了代码的意思，就开始尝试着写代码。写代码的过程有点别扭，刚开始接触，会犯一些错误。但是又不知道错误发生的原因，于是就开始google解决。也想吐槽一下文档，文档上说，fragment的name建议是fileName_propsName，于是为了名字短点，就全部改了，结果编译的时候，告诉我是must be。😢代码终于不报错了，但是需要一个schema的文件。我想手写schema太繁琐了，也是去查有没有自动生成schema的插件，但是很遗憾，我找到都是配合node使用的（假如你有好的插件，请推荐给我，谢谢）。找啊找，找啊找，也没找到合适的，最终是队长上网找了一个工具生成的🤗。schema的问题解决。schema的存在是为了映射fragment的type。这个时候，大哥过来问问我怎么样了，我告诉他，虽然安装了react-relay，可是文档上的方法不存在，我就很暴力的改了源码，将方法暴露出来。他告诉我relay现在有两个版本：classic和modern，modern是最新的。我弱弱的问一句，咱们用哪个版本，他说当然是最新的。我的内心在哭泣😭。既然只是版本的迭代，思想肯定没有太大的变化，于是打起精神来看文档。👉这里是我太心急了，直接看了Demo，就ctrl+f去直接搜方法了，没有整体的先浏览一下文档，要不然也不会有这个不可预料的情况。 第二天边看文档，边改我的代码。👉刚开始报错是“没有配置babel或者graphql写错了”，假如你的babel配置是按照文档来的，那最有可能的就是你的fragment或者query写错了。最简单的query可以正常的渲染出来了，因为是query中需要有参数，所以开始看如何使用参数。在查资料的时候，这个链接给了我很大的帮助。但是在这个过程中，下面的错误伴随了我十个小时，我一直在尝试解决这个错误，于是上网查啊查 查啊查 查啊查也没找到答案 第三天大哥说他写出来了，我看了他的代码，对比我的代码，唯一的不同是，我将edges和node要写在不同的fragment中。我尝试在正确的代码上改成我设计的fragment，功能就报错了。我意识到，需要将edges和node写在同一个fragment中。👉出现这个错误的原因是，我已经封装好的fragment，出现这个错误，我全部的心思都放在了index.js，没有检查我封装好的组件。假如再来一次，我也会被困在这个error上出不来。之后因为还有一个加载更多的动作，于是我开始完成这个功能，在这个过程中，我学会了react父子组件如何传递消息。 测试功能完成好了。但是在进行测试的时候，再看network时，加载更多这个按钮是通过first这个参数来进行请求数据，first的意思就是取前first数据，后端限制first只能取到50，即使可以取到1000，但是在网络上传输1000条数据，也是一笔庞大的负担。relay也提供了分页的container，但是没有研究出来是怎样使用的。于是relay需要更换….所以，没有一个很好的方式来解决这个问题。👉队长又给推荐了Apollo，接下来要去看Apollo了待续…]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechatPHP]]></title>
    <url>%2F2017%2F03%2F29%2FwechatPHP%2F</url>
    <content type="text"><![CDATA[使用apache+php5.4n1、打开apache配置文件httpd.conf 搜索httpd-vhosts.conf，打开这一行的注释2、打开apache所在目录下的，conf/extra/httpd-vhost.conf 增加以下代码，保存 &lt;VirtualHost *:80&gt; DocumentRoot &quot;D:\WWW\car-xxxx\car&quot; ServerName www.car-zones.com &lt;/VirtualHost&gt; &lt;Directory &quot;D:\WWW\car-xxxx\car&quot;&gt; Options Indexes FollowSymLinks Includes ExecCGI AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; 3、重启apache4、打开c:/windows/system32/drivers/etc/hots最后一行加入：www.car-xxxx.com5、访问 www.car-xxxx.com6、完成配置 第一次学习，记录一下]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dataTable]]></title>
    <url>%2F2017%2F03%2F26%2FdataTable%2F</url>
    <content type="text"><![CDATA[偶然发现一个叫 dataTable 的组件，觉得很好用，于是研究了一番，下面是代码 var lang = { "sProcessing": "处理中...", "sLengthMenu": "每页 _MENU_ 项", "sZeroRecords": "没有匹配结果", "sInfo": "当前显示第 _START_ 至 _END_ 项，共 _TOTAL_ 项。", "sInfoEmpty": "当前显示第 0 至 0 项，共 0 项", "sInfoFiltered": "(由 _MAX_ 项结果过滤)", "sInfoPostFix": "", "sSearch": "搜索:", "sUrl": "", "sEmptyTable": "表中数据为空", "sLoadingRecords": "载入中...", "sInfoThousands": ",", "oPaginate": { "sFirst": "首页", "sPrevious": "上页", "sNext": "下页", "sLast": "末页", "sJump": "跳转" }, "oAria": { "sSortAscending": ": 以升序排列此列", "sSortDescending": ": 以降序排列此列" } }; var table = $("#sample").dataTable({ language:lang, //提示信息 autoWidth: false, //禁用自动调整列宽 processing: true, //隐藏加载提示,自行处理 serverSide: true, //启用服务器端分页 searching: true, //禁用原生搜索 search: { "search": "" }, ordering:false, renderer: "bootstrap", //渲染样式：Bootstrap和jquery-ui lengthChange: false, pageLength:15, rowId: '_id', pagingType: "simple_numbers", //分页样式：simple,simple_numbers,full,full_numbers columnDefs: [{ "targets": 'nosort', //列的样式名 "orderable": false //包含上样式名‘nosort’的禁止排序 }], ajax: function (data, callback, settings) { //封装请求参数 var param = {}; param.keyword = data.search.value; param.limit = data.length;//页面显示记录条数，在页面显示每页显示多少项的时候 param.start = data.start;//开始的记录序号 param.page = (data.start / data.length)+1;//当前页码 //console.log(param); //ajax请求数据 $.ajax({ type: "POST", url: "/payment/result", cache: false, //禁用缓存 data: param, //传入组装的参数 dataType: "json", success: function (result) { //封装返回数据 var returnData = {}; returnData.draw = data.draw;//这里直接自行返回了draw计数器,应该由后台返回 returnData.recordsTotal = result.totalCount;//返回数据全部记录 returnData.recordsFiltered = result.totalCount;//后台不实现过滤功能，每次查询均视作全部结果 returnData.data = result.payment;//返回的数据列表 //调用DataTables提供的callback方法，代表数据已封装完成并传回DataTables进行渲染 //此时的数据需确保正确无误，异常判断应在执行此回调前自行处理完毕 callback(returnData); } }); }, //列表表头字段 columns: [ { className: "center", orderable : false, bSortable : false, data : "_id", render : function(data, type, row, meta) { var content = '&lt;label class="position-relative">'; content += '&lt;input type="checkbox" class="ace" value="' + data + '" />'; content += '&lt;span class="lbl">&lt;/span>'; content += '&lt;/label>'; return content; } }, { "data": "type", render:function(date,type,full) { var content = null; if(date == 1) { content = '收入'; } else { content = '支出'; } return content; } }, { "data": "name" }, { "data": "price" }, { "data": "product_type" }, { "data": "meta.createAt", render:function(date,type,full) { return date.slice(0,10); } }, { bSortable : false, visible : true, data : "_id", render : function(data, type, full) { var content = '&lt;div class="hidden-sm hidden-xs action-buttons">'+ '&lt;a href="/payment/detail/' + data + '" class="blue">'+ '&lt;i class="ace-icon fa fa-search-plus bigger-130">&lt;/i>'+ ' &lt;/a>'+ '&lt;a href="javascript:void(0);" data-id="' + data + '" class="delete_btn red">'+ '&lt;i class="ace-icon fa fa-trash-o bigger-130">&lt;/i>'+ '&lt;/a>'+ '&lt;/div>'+ '&lt;div class="hidden-md hidden-lg">'+ ' &lt;div class="inline position-relative">'+ ' &lt;button data-toggle="dropdown" data-position="auto" class="btn btn-minier btn-yellow dropdown-toggle">&lt;i class="ace-icon fa fa-caret-down icon-only bigger-120">&lt;/i>&lt;/button>'+ '&lt;ul class="dropdown-menu dropdown-only-icon dropdown-yellow dropdown-menu-right dropdown-caret dropdown-close">'+ ' &lt;li>&lt;a href="/payment/detail/' + data + '" data-rel="tooltip" title="" data-original-title="View" class="tooltip-info">&lt;span class="blue">&lt;i class="ace-icon fa fa-search-plus bigger-120">&lt;/i>&lt;/span>&lt;/a>'+ '&lt;li>&lt;a data-rel="tooltip" title="" data-original-title="Delete" data-id="' + data + '" class="delete_btn tooltip-error">&lt;span class="red">&lt;i class="ace-icon fa fa-trash-o bigger-120">&lt;/i>&lt;/span>&lt;/a>&lt;/li>'+ '&lt;/ul>&lt;/div>&lt;/div>'; return content; } } ] }).api(); //此处需调用api()方法,否则返回的是JQuery对象而不是DataTables的API对象 });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment]]></title>
    <url>%2F2016%2F12%2F11%2Fmoment%2F</url>
    <content type="text"><![CDATA[首先，好久没有来多博客了 今天在学习MongoDB时，需要格式化时间，上网查了一下，nodejs中的moment模块可以格式化时间。首先，mongodb中有一个字段是Date类型需要一个默认值，就是当前时间，可以使用以下代码来格式化时间 moment().format('YYYY-MM-DD HH:mm:ss') 使用以下代码也是可以的 moment(Date.now()).format('YYYY-MM-DD HH:mm:ss') 目前只使用这两个方法，以后再来补充——————————————————分割线———————————-在存入数据库时，我已经格式化日期了，取出来发现是没有格式的数据，很纳闷，不知道原因，找到了解决办法。express我是用的jade模板，在app.js中加入 app.locals.moment = require('moment') 在jade中读取日期数据使用 #{moment(friend.createTime).format('YYYY-MM-DD HH:mm:ss')} 取出来的日期是格式化的]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useMongoDB]]></title>
    <url>%2F2016%2F12%2F11%2FuseMongoDB%2F</url>
    <content type="text"><![CDATA[最近在学习mongdb 以下是使用mongoose模块来保存数据 var mongoose = require('mongoose'); var moment = require('moment'); // 连接字符串格式为mongodb://主机/数据库名 mongoose.connect('mongodb://localhost/test'); var db = mongoose.connection; //输出连接日志 db.on('error', function callback() { console.log("Connection error"); }); db.once('open', function callback() { console.log("Mongo working!"); }); // 创建schema var Schema = mongoose.Schema; var userSchema = new Schema({ name: String, age: Number, createTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, updateTime: { type: Date, default: moment().format('YYYY-MM-DD HH:mm:ss') }, telphone: String }); // 构建model var User = mongoose.model('User', userSchema); //构建model实例 var userData = new User({ name: 'root', age: 21, telphone: '18766560229' }); // 保存数据 userData.save(function(err) { if (err) { console.log(err) } else { console.log('Save success'); } }) 还有，输出信息有以下信息：(node:7780) DeprecationWarning: Mongoose: mpromise (mongoose’s default promise library) is deprecated, plug in your own promise library instead: http://mongoosejs.com/docs/promises.html也不不知道是什么意思，需要补充]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngInterpolate]]></title>
    <url>%2F2016%2F09%2F17%2FngInterpolate%2F</url>
    <content type="text"><![CDATA[$interpolate服务返回一个函数，用来在特定的上下文中运算表达式。示例：html代码： &lt;div ng-controller="myController"> &lt;input ng-model="to" type="email" placeholder="email" /> &lt;textarea ng-model="emailBody">&lt;/textarea> &lt;pre>{{previewText}}&lt;/pre> &lt;/div> js代码： angular.module('myApp', []) .controller('myController',['$scope','$interpolate', function($scope,$interpolate) { $scope.$watch('emailBody',function(body) { if(body) { var template = $interpolate(body); $scope.previewText = template({to:$scope.to}) } }) } ]) 使用：在输入框中输入你的email地址，在文本框中输入，previewText中的值即为to的值]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java1]]></title>
    <url>%2F2016%2F07%2F20%2Fjava1%2F</url>
    <content type="text"><![CDATA[Java已经忘了差不多了，最近又需要重新捡起Java。对于一副扑克牌共有54张，扑克牌洗牌就是将这54张牌没有规律的输出出来，用ArrayList实现，本质是54个数的随机输出，穿了身衣服，输出出来就好看多了 public class Poker { public static String poker(int num) { String str = ""; String[] huase = {"红桃","黑桃","梅花","方块"}; String[] number = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"}; if(num/4 > 12) { if(num%4 == 0) { str += "小鬼"; } else if(num%4 == 1) { str += "大鬼"; } } else { str += huase[num%4] + number[num/4] ; } return str; } } public class Client { public static void main(String[] args) { // 定义变量 ArrayList list = new ArrayList(); Random random = new Random(); Poker poker = new Poker(); int i = 0; // 向数组中增加数字 for(i=0;i&lt;54;i++) { list.add(poker.poker(i)); } // 随机输出数组中的每个数字 int length = list.size(); for(i=0;i&lt;length;i++) { //随机生成数组下标 int num = random.nextInt(list.size()); //取出数字 System.out.println(list.get(num)); //将数字从数组中移除 list.remove(num); } } } 看起来舒服多了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-margin]]></title>
    <url>%2F2016%2F07%2F16%2Fcss-margin%2F</url>
    <content type="text"><![CDATA[今天在慕课上看了张大神又一力作，整理了一下margin的巧妙使用：1、margin实现自适应的宽高比为2：1的矩形 &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; #container { width: 400px; height: 250px; } .box { background-color: olive; overflow: hidden; } .box &gt; div { margin: 50%; } &lt;/style&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
